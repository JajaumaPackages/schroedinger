diff -uNr schroedinger-1.0.8.orig/gst/gstschro.c schroedinger-1.0.8/gst/gstschro.c
--- schroedinger-1.0.8.orig/gst/gstschro.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst/gstschro.c	2009-09-11 17:35:39.000000000 +0200
@@ -0,0 +1,54 @@
+/* GStreamer
+ * Copyright (C) 2005 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <schroedinger/schro.h>
+
+GType gst_schro_enc_get_type (void);
+GType gst_schro_dec_get_type (void);
+GType gst_schro_parse_get_type (void);
+
+GST_DEBUG_CATEGORY (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  schro_init ();
+
+  GST_DEBUG_CATEGORY_INIT (schro_debug, "schro", 0, "Schroedinger");
+  gst_element_register (plugin, "schrodec", GST_RANK_PRIMARY,
+      gst_schro_dec_get_type ());
+  gst_element_register (plugin, "schroparse", GST_RANK_NONE,
+      gst_schro_parse_get_type ());
+  gst_element_register (plugin, "schroenc", GST_RANK_PRIMARY,
+      gst_schro_enc_get_type ());
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "schro",
+    "Schroedinger plugin",
+    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff -uNr schroedinger-1.0.8.orig/gst/gstschrodec.c schroedinger-1.0.8/gst/gstschrodec.c
--- schroedinger-1.0.8.orig/gst/gstschrodec.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst/gstschrodec.c	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,728 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+#include <gst/video/video.h>
+#include <gst/video/gstbasevideodecoder.h>
+#include <string.h>
+#include <schroedinger/schro.h>
+#include <math.h>
+#include "gstschroutils.h"
+
+#include <schroedinger/schroparse.h>
+
+GST_DEBUG_CATEGORY_EXTERN (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+#define GST_TYPE_SCHRO_DEC \
+  (gst_schro_dec_get_type())
+#define GST_SCHRO_DEC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SCHRO_DEC,GstSchroDec))
+#define GST_SCHRO_DEC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SCHRO_DEC,GstSchroDecClass))
+#define GST_IS_SCHRO_DEC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SCHRO_DEC))
+#define GST_IS_SCHRO_DEC_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SCHRO_DEC))
+
+typedef struct _GstSchroDec GstSchroDec;
+typedef struct _GstSchroDecClass GstSchroDecClass;
+
+struct _GstSchroDec
+{
+  GstBaseVideoDecoder base_video_decoder;
+
+  SchroDecoder *decoder;
+
+  GstBuffer *seq_header_buffer;
+};
+
+struct _GstSchroDecClass
+{
+  GstBaseVideoDecoder base_video_decoder_class;
+};
+
+
+/* GstSchroDec signals and args */
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_schro_dec_finalize (GObject * object);
+static void gst_schro_dec_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_schro_dec_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static gboolean gst_schro_dec_sink_query (GstPad * pad, GstQuery * query);
+
+static gboolean gst_schro_dec_start (GstBaseVideoDecoder * dec);
+static gboolean gst_schro_dec_stop (GstBaseVideoDecoder * dec);
+static gboolean gst_schro_dec_reset (GstBaseVideoDecoder * dec);
+static GstFlowReturn gst_schro_dec_parse_data (GstBaseVideoDecoder *
+    base_video_decoder, gboolean at_eos);
+static int gst_schro_dec_scan_for_sync (GstBaseVideoDecoder *
+    base_video_decoder, gboolean at_eos, int offset, int n);
+static GstFlowReturn gst_schro_dec_handle_frame (GstBaseVideoDecoder * decoder,
+    GstVideoFrame * frame);
+static GstFlowReturn gst_schro_dec_finish (GstBaseVideoDecoder *
+    base_video_decoder, GstVideoFrame * frame);
+static void gst_schrodec_send_tags (GstSchroDec * schro_dec);
+
+static GstStaticPadTemplate gst_schro_dec_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-dirac")
+    );
+
+static GstStaticPadTemplate gst_schro_dec_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("{ I420, YUY2, AYUV }"))
+    );
+
+GST_BOILERPLATE (GstSchroDec, gst_schro_dec, GstBaseVideoDecoder,
+    GST_TYPE_BASE_VIDEO_DECODER);
+
+static void
+gst_schro_dec_base_init (gpointer g_class)
+{
+  static GstElementDetails compress_details =
+      GST_ELEMENT_DETAILS ("Dirac Decoder",
+      "Codec/Decoder/Video",
+      "Decode Dirac streams",
+      "David Schleef <ds@schleef.org>");
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_dec_src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_dec_sink_template));
+
+  gst_element_class_set_details (element_class, &compress_details);
+}
+
+static void
+gst_schro_dec_class_init (GstSchroDecClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstElementClass *element_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+  base_video_decoder_class = GST_BASE_VIDEO_DECODER_CLASS (klass);
+
+  gobject_class->set_property = gst_schro_dec_set_property;
+  gobject_class->get_property = gst_schro_dec_get_property;
+  gobject_class->finalize = gst_schro_dec_finalize;
+
+  base_video_decoder_class->start = GST_DEBUG_FUNCPTR (gst_schro_dec_start);
+  base_video_decoder_class->stop = GST_DEBUG_FUNCPTR (gst_schro_dec_stop);
+  base_video_decoder_class->reset = GST_DEBUG_FUNCPTR (gst_schro_dec_reset);
+  base_video_decoder_class->parse_data =
+      GST_DEBUG_FUNCPTR (gst_schro_dec_parse_data);
+  base_video_decoder_class->scan_for_sync =
+      GST_DEBUG_FUNCPTR (gst_schro_dec_scan_for_sync);
+  base_video_decoder_class->handle_frame =
+      GST_DEBUG_FUNCPTR (gst_schro_dec_handle_frame);
+  base_video_decoder_class->finish = GST_DEBUG_FUNCPTR (gst_schro_dec_finish);
+}
+
+static void
+gst_schro_dec_init (GstSchroDec * schro_dec, GstSchroDecClass * klass)
+{
+  GST_DEBUG ("gst_schro_dec_init");
+
+  gst_pad_set_query_function (GST_BASE_VIDEO_CODEC_SINK_PAD (schro_dec),
+      gst_schro_dec_sink_query);
+
+  schro_dec->decoder = schro_decoder_new ();
+}
+
+#define OGG_DIRAC_GRANULE_SHIFT 22
+#define OGG_DIRAC_GRANULE_LOW_MASK ((1ULL<<OGG_DIRAC_GRANULE_SHIFT)-1)
+
+static gint64
+granulepos_to_frame (gint64 granulepos)
+{
+  guint64 pt;
+  int dist_h;
+  int dist_l;
+  int dist;
+  int delay;
+  guint64 dt;
+
+  if (granulepos == -1)
+    return -1;
+
+  pt = ((granulepos >> 22) + (granulepos & OGG_DIRAC_GRANULE_LOW_MASK)) >> 9;
+  dist_h = (granulepos >> 22) & 0xff;
+  dist_l = granulepos & 0xff;
+  dist = (dist_h << 8) | dist_l;
+  delay = (granulepos >> 9) & 0x1fff;
+  dt = pt - delay;
+
+  return pt >> 1;
+}
+
+static gboolean
+gst_schro_dec_sink_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstSchroDec *dec;
+  GstVideoState *state;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_SCHRO_DEC (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a decoding state */
+
+  state = gst_base_video_decoder_get_state (GST_BASE_VIDEO_DECODER (dec));
+
+  res = FALSE;
+  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
+    if (state->fps_d != 0) {
+      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+          state->fps_d * GST_SECOND, state->fps_n);
+      res = TRUE;
+    } else {
+      res = FALSE;
+    }
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+
+static gboolean
+gst_schro_dec_sink_query (GstPad * pad, GstQuery * query)
+{
+  GstSchroDec *dec;
+  gboolean res = FALSE;
+
+  dec = GST_SCHRO_DEC (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_schro_dec_sink_convert (pad, src_fmt, src_val, &dest_fmt,
+          &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (dec);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (dec, "query failed");
+  goto done;
+}
+
+static gboolean
+gst_schro_dec_start (GstBaseVideoDecoder * dec)
+{
+  if (dec->codec_data) {
+    GST_DEBUG_OBJECT (dec, "codec data!");
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_schro_dec_stop (GstBaseVideoDecoder * dec)
+{
+
+  return TRUE;
+}
+
+static gboolean
+gst_schro_dec_reset (GstBaseVideoDecoder * dec)
+{
+  GstSchroDec *schro_dec;
+
+  schro_dec = GST_SCHRO_DEC (dec);
+
+  GST_DEBUG ("reset");
+
+  if (schro_dec->decoder) {
+    schro_decoder_reset (schro_dec->decoder);
+  }
+
+  return TRUE;
+}
+
+static void
+gst_schro_dec_finalize (GObject * object)
+{
+  GstSchroDec *schro_dec;
+
+  g_return_if_fail (GST_IS_SCHRO_DEC (object));
+  schro_dec = GST_SCHRO_DEC (object);
+
+  if (schro_dec->decoder) {
+    schro_decoder_free (schro_dec->decoder);
+    schro_dec->decoder = NULL;
+  }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_schro_dec_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSchroDec *src;
+
+  g_return_if_fail (GST_IS_SCHRO_DEC (object));
+  src = GST_SCHRO_DEC (object);
+
+  GST_DEBUG ("gst_schro_dec_set_property");
+  switch (prop_id) {
+    default:
+      break;
+  }
+}
+
+static void
+gst_schro_dec_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  GstSchroDec *src;
+
+  g_return_if_fail (GST_IS_SCHRO_DEC (object));
+  src = GST_SCHRO_DEC (object);
+
+  switch (prop_id) {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+parse_sequence_header (GstSchroDec * schro_dec, guint8 * data, int size)
+{
+  SchroVideoFormat video_format;
+  int ret;
+  GstVideoState *state;
+
+  GST_DEBUG_OBJECT (schro_dec, "parse_sequence_header size=%d", size);
+
+  state = gst_base_video_decoder_get_state (GST_BASE_VIDEO_DECODER (schro_dec));
+
+  schro_dec->seq_header_buffer = gst_buffer_new_and_alloc (size);
+  memcpy (GST_BUFFER_DATA (schro_dec->seq_header_buffer), data, size);
+
+  ret = schro_parse_decode_sequence_header (data + 13, size - 13,
+      &video_format);
+  if (ret) {
+    if (video_format.chroma_format == SCHRO_CHROMA_444) {
+      state->format = GST_VIDEO_FORMAT_AYUV;
+    } else if (video_format.chroma_format == SCHRO_CHROMA_422) {
+      state->format = GST_VIDEO_FORMAT_YUY2;
+    } else if (video_format.chroma_format == SCHRO_CHROMA_420) {
+      state->format = GST_VIDEO_FORMAT_I420;
+    }
+    state->fps_n = video_format.frame_rate_numerator;
+    state->fps_d = video_format.frame_rate_denominator;
+    GST_DEBUG_OBJECT (schro_dec, "Frame rate is %d/%d", state->fps_n,
+        state->fps_d);
+
+    state->width = video_format.width;
+    state->height = video_format.height;
+    GST_DEBUG ("Frame dimensions are %d x %d\n", state->width, state->height);
+
+    state->clean_width = video_format.clean_width;
+    state->clean_height = video_format.clean_height;
+    state->clean_offset_left = video_format.left_offset;
+    state->clean_offset_top = video_format.top_offset;
+
+    state->par_n = video_format.aspect_ratio_numerator;
+    state->par_d = video_format.aspect_ratio_denominator;
+    GST_DEBUG ("Pixel aspect ratio is %d/%d", state->par_n, state->par_d);
+
+    /* FIXME state points to what is actually in the decoder */
+    //gst_base_video_decoder_set_state (GST_BASE_VIDEO_DECODER (schro_dec),
+    //    state);
+  } else {
+    GST_WARNING ("Failed to get frame rate from sequence header");
+  }
+
+  gst_schrodec_send_tags (schro_dec);
+}
+
+
+static GstFlowReturn
+gst_schro_dec_parse_data (GstBaseVideoDecoder * base_video_decoder,
+    gboolean at_eos)
+{
+  GstSchroDec *schro_decoder;
+  unsigned char header[SCHRO_PARSE_HEADER_SIZE];
+  int next;
+  int prev;
+  int parse_code;
+
+  GST_DEBUG_OBJECT (base_video_decoder, "parse_data");
+
+  schro_decoder = GST_SCHRO_DEC (base_video_decoder);
+
+  if (gst_adapter_available (base_video_decoder->input_adapter) <
+      SCHRO_PARSE_HEADER_SIZE) {
+    return GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA;
+  }
+
+  GST_DEBUG ("available %d",
+      gst_adapter_available (base_video_decoder->input_adapter));
+
+  gst_adapter_copy (base_video_decoder->input_adapter, header, 0,
+      SCHRO_PARSE_HEADER_SIZE);
+
+  parse_code = header[4];
+  next = GST_READ_UINT32_BE (header + 5);
+  prev = GST_READ_UINT32_BE (header + 9);
+
+  GST_DEBUG ("%08x %02x %08x %08x",
+      GST_READ_UINT32_BE (header), parse_code, next, prev);
+
+  if (memcmp (header, "BBCD", 4) != 0 ||
+      (next & 0xf0000000) || (prev & 0xf0000000)) {
+    gst_base_video_decoder_lost_sync (base_video_decoder);
+    return GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE (parse_code)) {
+    GstVideoFrame *frame;
+
+    if (next != 0 && next != SCHRO_PARSE_HEADER_SIZE) {
+      GST_WARNING ("next is not 0 or 13 in EOS packet (%d)", next);
+    }
+
+    gst_base_video_decoder_add_to_frame (base_video_decoder,
+        SCHRO_PARSE_HEADER_SIZE);
+
+    frame = base_video_decoder->current_frame;
+    frame->is_eos = TRUE;
+
+    SCHRO_DEBUG ("eos");
+
+    return gst_base_video_decoder_have_frame (base_video_decoder);
+  }
+
+  if (gst_adapter_available (base_video_decoder->input_adapter) < next) {
+    return GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_SEQ_HEADER (parse_code)) {
+    guint8 *data;
+
+    data = g_malloc (next);
+
+    gst_adapter_copy (base_video_decoder->input_adapter, data, 0, next);
+    parse_sequence_header (schro_decoder, data, next);
+
+    gst_base_video_decoder_set_sync_point (base_video_decoder);
+
+    if (GST_CLOCK_TIME_IS_VALID (base_video_decoder->last_sink_timestamp)) {
+      base_video_decoder->current_frame->presentation_timestamp =
+          base_video_decoder->last_sink_timestamp;
+      GST_DEBUG ("got timestamp %" G_GINT64_FORMAT,
+          base_video_decoder->last_sink_timestamp);
+    } else if (base_video_decoder->last_sink_offset_end != -1) {
+      GstVideoState *state;
+
+#if 0
+      /* FIXME perhaps should use this to determine if the granulepos
+       * is valid */
+      {
+        guint64 pt;
+        int dist_h;
+        int dist_l;
+        int dist;
+        int delay;
+        guint64 dt;
+        gint64 granulepos = base_video_decoder->last_sink_offset_end;
+
+        pt = ((granulepos >> 22) +
+            (granulepos & OGG_DIRAC_GRANULE_LOW_MASK)) >> 9;
+        dist_h = (granulepos >> 22) & 0xff;
+        dist_l = granulepos & 0xff;
+        dist = (dist_h << 8) | dist_l;
+        delay = (granulepos >> 9) & 0x1fff;
+        dt = pt - delay;
+        GST_DEBUG ("gp pt %lld dist %d delay %d dt %lld", pt, dist, delay, dt);
+      }
+#endif
+      state =
+          gst_base_video_decoder_get_state (GST_BASE_VIDEO_DECODER
+          (schro_decoder));
+      base_video_decoder->current_frame->presentation_timestamp =
+          gst_util_uint64_scale (granulepos_to_frame
+          (base_video_decoder->last_sink_offset_end), state->fps_d * GST_SECOND,
+          state->fps_n);
+    } else {
+      base_video_decoder->current_frame->presentation_timestamp = -1;
+    }
+
+    g_free (data);
+  }
+
+  if (schro_decoder->seq_header_buffer == NULL) {
+    gst_adapter_flush (base_video_decoder->input_adapter, next);
+    return GST_FLOW_OK;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_PICTURE (parse_code)) {
+    GstVideoFrame *frame;
+    guint8 tmp[4];
+
+    frame = base_video_decoder->current_frame;
+
+    gst_adapter_copy (base_video_decoder->input_adapter, tmp,
+        SCHRO_PARSE_HEADER_SIZE, 4);
+
+    frame->presentation_frame_number = GST_READ_UINT32_BE (tmp);
+
+    gst_base_video_decoder_add_to_frame (base_video_decoder, next);
+
+    return gst_base_video_decoder_have_frame (base_video_decoder);
+  } else {
+    gst_base_video_decoder_add_to_frame (base_video_decoder, next);
+  }
+
+  return GST_FLOW_OK;
+}
+
+static int
+gst_schro_dec_scan_for_sync (GstBaseVideoDecoder * base_video_decoder,
+    gboolean at_eos, int offset, int n)
+{
+  GstAdapter *adapter = base_video_decoder->input_adapter;
+  int n_available;
+  int ret;
+
+  n_available = gst_adapter_available (adapter) - offset;
+
+  if (n_available < 4) {
+    if (at_eos) {
+      return n_available;
+    } else {
+      return 0;
+    }
+  }
+
+  n = MIN (n, n_available - 3);
+
+  ret = gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x42424344,
+      offset, n);
+  if (ret == -1) {
+    return n;
+  }
+  return ret;
+}
+
+
+static void
+gst_schrodec_send_tags (GstSchroDec * schro_dec)
+{
+  GstTagList *list;
+
+  list = gst_tag_list_new ();
+  gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+      GST_TAG_VIDEO_CODEC, "Dirac", NULL);
+
+  gst_element_found_tags_for_pad (GST_ELEMENT_CAST (schro_dec),
+      GST_BASE_VIDEO_CODEC_SRC_PAD (schro_dec), list);
+}
+
+static GstFlowReturn
+gst_schro_dec_process (GstSchroDec * schro_dec, gboolean eos)
+{
+  gboolean go;
+  GstFlowReturn ret;
+
+  ret = GST_FLOW_OK;
+  go = TRUE;
+  while (go) {
+    int it;
+
+    it = schro_decoder_autoparse_wait (schro_dec->decoder);
+
+    switch (it) {
+      case SCHRO_DECODER_FIRST_ACCESS_UNIT:
+        break;
+      case SCHRO_DECODER_NEED_BITS:
+        GST_DEBUG ("need bits");
+        go = 0;
+        break;
+      case SCHRO_DECODER_NEED_FRAME:
+      {
+        GstBuffer *outbuf;
+        GstVideoState *state;
+        SchroFrame *schro_frame;
+        GstFlowReturn flow_ret;
+        int size;
+
+        GST_DEBUG ("need frame");
+
+        state =
+            gst_base_video_decoder_get_state (GST_BASE_VIDEO_DECODER
+            (schro_dec));
+        size =
+            gst_video_format_get_size (state->format, state->width,
+            state->height);
+        flow_ret =
+            gst_pad_alloc_buffer_and_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
+            (schro_dec), GST_BUFFER_OFFSET_NONE, size,
+            GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (schro_dec)), &outbuf);
+        if (flow_ret != GST_FLOW_OK) {
+          go = FALSE;
+          ret = flow_ret;
+          break;
+        }
+        schro_frame = gst_schro_buffer_wrap (outbuf,
+            state->format, state->width, state->height);
+        schro_decoder_add_output_picture (schro_dec->decoder, schro_frame);
+        break;
+      }
+      case SCHRO_DECODER_OK:
+      {
+        SchroFrame *schro_frame;
+        SchroTag *tag;
+        GstVideoFrame *frame;
+
+        GST_DEBUG ("got frame");
+
+        tag = schro_decoder_get_picture_tag (schro_dec->decoder);
+        schro_frame = schro_decoder_pull (schro_dec->decoder);
+        frame = tag->value;
+
+        if (schro_frame) {
+          if (schro_frame->priv) {
+            GstFlowReturn flow_ret;
+
+            frame->src_buffer = gst_buffer_ref (GST_BUFFER (schro_frame->priv));
+
+            flow_ret =
+                gst_base_video_decoder_finish_frame (GST_BASE_VIDEO_DECODER
+                (schro_dec), frame);
+            if (flow_ret != GST_FLOW_OK) {
+              GST_DEBUG ("finish frame returned %d", flow_ret);
+              return flow_ret;
+            }
+          } else {
+            GST_DEBUG ("skipped frame");
+          }
+
+          schro_frame_unref (schro_frame);
+        }
+        if (!eos) {
+          go = FALSE;
+        }
+      }
+
+        break;
+      case SCHRO_DECODER_EOS:
+        GST_DEBUG ("eos");
+        go = FALSE;
+        break;
+      case SCHRO_DECODER_ERROR:
+        go = FALSE;
+        GST_DEBUG ("codec error");
+        ret = GST_FLOW_ERROR;
+        break;
+    }
+  }
+  return ret;
+}
+
+GstFlowReturn
+gst_schro_dec_handle_frame (GstBaseVideoDecoder * base_video_decoder,
+    GstVideoFrame * frame)
+{
+  GstSchroDec *schro_dec;
+  int schro_ret;
+  SchroBuffer *input_buffer;
+  GstVideoState *state;
+
+  schro_dec = GST_SCHRO_DEC (base_video_decoder);
+
+  GST_DEBUG ("handle frame");
+
+  state = gst_base_video_decoder_get_state (base_video_decoder);
+
+  gst_base_video_decoder_set_src_caps (base_video_decoder);
+
+  input_buffer = gst_schro_wrap_gst_buffer (frame->sink_buffer);
+  frame->sink_buffer = NULL;
+
+  input_buffer->tag = schro_tag_new (frame, NULL);
+
+  schro_ret = schro_decoder_autoparse_push (schro_dec->decoder, input_buffer);
+
+  return gst_schro_dec_process (schro_dec, FALSE);
+}
+
+GstFlowReturn
+gst_schro_dec_finish (GstBaseVideoDecoder * base_video_decoder,
+    GstVideoFrame * frame)
+{
+  GstSchroDec *schro_dec;
+
+  schro_dec = GST_SCHRO_DEC (base_video_decoder);
+
+  GST_DEBUG ("finish");
+
+  gst_base_video_decoder_set_src_caps (base_video_decoder);
+
+  schro_decoder_autoparse_push_end_of_sequence (schro_dec->decoder);
+
+  return gst_schro_dec_process (schro_dec, TRUE);
+}
diff -uNr schroedinger-1.0.8.orig/gst/gstschroenc.c schroedinger-1.0.8/gst/gstschroenc.c
--- schroedinger-1.0.8.orig/gst/gstschroenc.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst/gstschroenc.c	2009-10-23 22:02:51.000000000 +0200
@@ -0,0 +1,791 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstbasevideoencoder.h>
+#include <string.h>
+
+#include <schroedinger/schro.h>
+#include <schroedinger/schrobitstream.h>
+#include <schroedinger/schrovirtframe.h>
+#include <math.h>
+#include "gstschroutils.h"
+
+GST_DEBUG_CATEGORY_EXTERN (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+#define GST_TYPE_SCHRO_ENC \
+  (gst_schro_enc_get_type())
+#define GST_SCHRO_ENC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SCHRO_ENC,GstSchroEnc))
+#define GST_SCHRO_ENC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SCHRO_ENC,GstSchroEncClass))
+#define GST_IS_SCHRO_ENC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SCHRO_ENC))
+#define GST_IS_SCHRO_ENC_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SCHRO_ENC))
+
+typedef struct _GstSchroEnc GstSchroEnc;
+typedef struct _GstSchroEncClass GstSchroEncClass;
+
+typedef enum
+{
+  GST_SCHRO_ENC_OUTPUT_OGG,
+  GST_SCHRO_ENC_OUTPUT_QUICKTIME,
+  GST_SCHRO_ENC_OUTPUT_AVI,
+  GST_SCHRO_ENC_OUTPUT_MPEG_TS,
+  GST_SCHRO_ENC_OUTPUT_MP4
+} GstSchroEncOutputType;
+
+struct _GstSchroEnc
+{
+  GstBaseVideoEncoder base_encoder;
+
+  GstPad *sinkpad;
+  GstPad *srcpad;
+
+  /* video properties */
+  GstSchroEncOutputType output_format;
+
+  /* state */
+  SchroEncoder *encoder;
+  SchroVideoFormat *video_format;
+  GstVideoFrame *eos_frame;
+  GstBuffer *seq_header_buffer;
+
+  guint64 last_granulepos;
+  guint64 granule_offset;
+};
+
+struct _GstSchroEncClass
+{
+  GstBaseVideoEncoderClass parent_class;
+};
+
+
+
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_schro_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_schro_enc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static GstFlowReturn gst_schro_enc_process (GstSchroEnc * schro_enc);
+
+static gboolean gst_schro_enc_set_format (GstBaseVideoEncoder *
+    base_video_encoder, GstVideoState * state);
+static gboolean gst_schro_enc_start (GstBaseVideoEncoder * base_video_encoder);
+static gboolean gst_schro_enc_stop (GstBaseVideoEncoder * base_video_encoder);
+static gboolean gst_schro_enc_finish (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame);
+static GstFlowReturn gst_schro_enc_handle_frame (GstBaseVideoEncoder *
+    base_video_encoder, GstVideoFrame * frame);
+static GstFlowReturn gst_schro_enc_shape_output (GstBaseVideoEncoder *
+    base_video_encoder, GstVideoFrame * frame);
+static GstCaps *gst_schro_enc_get_caps (GstBaseVideoEncoder *
+    base_video_encoder);
+
+static GstStaticPadTemplate gst_schro_enc_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("{ I420, YV12, YUY2, UYVY, AYUV }"))
+    );
+
+static GstStaticPadTemplate gst_schro_enc_src_template =
+    GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-dirac;video/x-qt-part;video/x-mp4-part")
+    );
+
+GST_BOILERPLATE (GstSchroEnc, gst_schro_enc, GstBaseVideoEncoder,
+    GST_TYPE_BASE_VIDEO_ENCODER);
+
+static void
+gst_schro_enc_base_init (gpointer g_class)
+{
+  static GstElementDetails schro_enc_details =
+      GST_ELEMENT_DETAILS ("Dirac Encoder",
+      "Codec/Encoder/Video",
+      "Encode raw video into Dirac stream",
+      "David Schleef <ds@schleef.org>");
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_enc_src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_enc_sink_template));
+
+  gst_element_class_set_details (element_class, &schro_enc_details);
+}
+
+static GType
+register_enum_list (const SchroEncoderSetting * setting)
+{
+  GType type;
+  static GEnumValue *enumtypes;
+  int n;
+  char *typename;
+  int i;
+
+  n = setting->max + 1;
+
+  enumtypes = g_malloc0 ((n + 1) * sizeof (GEnumValue));
+  for (i = 0; i < n; i++) {
+    enumtypes[i].value = i;
+    enumtypes[i].value_name = setting->enum_list[i];
+    enumtypes[i].value_nick = setting->enum_list[i];
+  }
+
+  typename = g_strdup_printf ("SchroEncoderSettingEnum_%s", setting->name);
+  type = g_enum_register_static (typename, enumtypes);
+  g_free (typename);
+
+  return type;
+}
+
+static void
+gst_schro_enc_class_init (GstSchroEncClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseVideoEncoderClass *basevideocoder_class;
+  int i;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+  basevideocoder_class = GST_BASE_VIDEO_ENCODER_CLASS (klass);
+
+  gobject_class->set_property = gst_schro_enc_set_property;
+  gobject_class->get_property = gst_schro_enc_get_property;
+
+  for (i = 0; i < schro_encoder_get_n_settings (); i++) {
+    const SchroEncoderSetting *setting;
+
+    setting = schro_encoder_get_setting_info (i);
+
+    switch (setting->type) {
+      case SCHRO_ENCODER_SETTING_TYPE_BOOLEAN:
+        g_object_class_install_property (gobject_class, i + 1,
+            g_param_spec_boolean (setting->name, setting->name, setting->name,
+                setting->default_value, G_PARAM_READWRITE));
+        break;
+      case SCHRO_ENCODER_SETTING_TYPE_INT:
+        g_object_class_install_property (gobject_class, i + 1,
+            g_param_spec_int (setting->name, setting->name, setting->name,
+                setting->min, setting->max, setting->default_value,
+                G_PARAM_READWRITE));
+        break;
+      case SCHRO_ENCODER_SETTING_TYPE_ENUM:
+        g_object_class_install_property (gobject_class, i + 1,
+            g_param_spec_enum (setting->name, setting->name, setting->name,
+                register_enum_list (setting), setting->default_value,
+                G_PARAM_READWRITE));
+        break;
+      case SCHRO_ENCODER_SETTING_TYPE_DOUBLE:
+        g_object_class_install_property (gobject_class, i + 1,
+            g_param_spec_double (setting->name, setting->name, setting->name,
+                setting->min, setting->max, setting->default_value,
+                G_PARAM_READWRITE));
+        break;
+      default:
+        break;
+    }
+  }
+
+  basevideocoder_class->set_format =
+      GST_DEBUG_FUNCPTR (gst_schro_enc_set_format);
+  basevideocoder_class->start = GST_DEBUG_FUNCPTR (gst_schro_enc_start);
+  basevideocoder_class->stop = GST_DEBUG_FUNCPTR (gst_schro_enc_stop);
+  basevideocoder_class->finish = GST_DEBUG_FUNCPTR (gst_schro_enc_finish);
+  basevideocoder_class->handle_frame =
+      GST_DEBUG_FUNCPTR (gst_schro_enc_handle_frame);
+  basevideocoder_class->shape_output =
+      GST_DEBUG_FUNCPTR (gst_schro_enc_shape_output);
+  basevideocoder_class->get_caps = GST_DEBUG_FUNCPTR (gst_schro_enc_get_caps);
+}
+
+static void
+gst_schro_enc_init (GstSchroEnc * schro_enc, GstSchroEncClass * klass)
+{
+  GST_DEBUG ("gst_schro_enc_init");
+
+  /* Normally, we'd create the encoder in ->start(), but we use the
+   * encoder to store object properties.  So it needs to be created
+   * here. */
+  schro_enc->encoder = schro_encoder_new ();
+  schro_encoder_set_packet_assembly (schro_enc->encoder, TRUE);
+  schro_enc->video_format = schro_encoder_get_video_format (schro_enc->encoder);
+}
+
+
+
+static gboolean
+gst_schro_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoState * state)
+{
+  GstCaps *caps;
+  GstStructure *structure;
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  GST_DEBUG ("set_output_caps");
+  caps =
+      gst_pad_get_allowed_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
+      (base_video_encoder));
+  if (caps == NULL) {
+    caps =
+        gst_caps_copy (gst_pad_get_pad_template_caps
+        (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder)));
+  }
+
+  if (gst_caps_is_empty (caps)) {
+    gst_caps_unref (caps);
+    return FALSE;
+  }
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  if (gst_structure_has_name (structure, "video/x-dirac")) {
+    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_OGG;
+  } else if (gst_structure_has_name (structure, "video/x-qt-part")) {
+    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_QUICKTIME;
+  } else if (gst_structure_has_name (structure, "video/x-avi-part")) {
+    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_AVI;
+  } else if (gst_structure_has_name (structure, "video/x-mp4-part")) {
+    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_MP4;
+  } else {
+    gst_caps_unref (caps);
+    return FALSE;
+  }
+
+  gst_caps_unref (caps);
+
+  gst_base_video_encoder_set_latency_fields (base_video_encoder,
+      2 * (int) schro_encoder_setting_get_double (schro_enc->encoder,
+          "queue_depth"));
+
+  schro_video_format_set_std_video_format (schro_enc->video_format,
+      SCHRO_VIDEO_FORMAT_CUSTOM);
+
+  switch (state->format) {
+    case GST_VIDEO_FORMAT_I420:
+    case GST_VIDEO_FORMAT_YV12:
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_420;
+      break;
+    case GST_VIDEO_FORMAT_YUY2:
+    case GST_VIDEO_FORMAT_UYVY:
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_422;
+      break;
+    case GST_VIDEO_FORMAT_AYUV:
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_444;
+      break;
+    case GST_VIDEO_FORMAT_ARGB:
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_420;
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  schro_enc->video_format->frame_rate_numerator = state->fps_n;
+  schro_enc->video_format->frame_rate_denominator = state->fps_d;
+
+  schro_enc->video_format->width = state->width;
+  schro_enc->video_format->height = state->height;
+  schro_enc->video_format->clean_width = state->clean_width;
+  schro_enc->video_format->clean_height = state->clean_height;
+  schro_enc->video_format->left_offset = state->clean_offset_left;
+  schro_enc->video_format->top_offset = state->clean_offset_top;
+
+  schro_enc->video_format->aspect_ratio_numerator = state->par_n;
+  schro_enc->video_format->aspect_ratio_denominator = state->par_d;
+
+  schro_video_format_set_std_signal_range (schro_enc->video_format,
+      SCHRO_SIGNAL_RANGE_8BIT_VIDEO);
+  schro_video_format_set_std_colour_spec (schro_enc->video_format,
+      SCHRO_COLOUR_SPEC_HDTV);
+
+  schro_encoder_set_video_format (schro_enc->encoder, schro_enc->video_format);
+  schro_encoder_start (schro_enc->encoder);
+
+  schro_enc->seq_header_buffer =
+      gst_schro_wrap_schro_buffer (schro_encoder_encode_sequence_header
+      (schro_enc->encoder));
+
+  return TRUE;
+}
+
+static void
+gst_schro_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSchroEnc *src;
+
+  g_return_if_fail (GST_IS_SCHRO_ENC (object));
+  src = GST_SCHRO_ENC (object);
+
+  GST_DEBUG ("gst_schro_enc_set_property");
+
+  if (prop_id >= 1) {
+    const SchroEncoderSetting *setting;
+    setting = schro_encoder_get_setting_info (prop_id - 1);
+    switch (G_VALUE_TYPE (value)) {
+      case G_TYPE_DOUBLE:
+        schro_encoder_setting_set_double (src->encoder, setting->name,
+            g_value_get_double (value));
+        break;
+      case G_TYPE_INT:
+        schro_encoder_setting_set_double (src->encoder, setting->name,
+            g_value_get_int (value));
+        break;
+      case G_TYPE_BOOLEAN:
+        schro_encoder_setting_set_double (src->encoder, setting->name,
+            g_value_get_boolean (value));
+        break;
+      default:
+        schro_encoder_setting_set_double (src->encoder, setting->name,
+            g_value_get_enum (value));
+        break;
+    }
+  }
+}
+
+static void
+gst_schro_enc_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  GstSchroEnc *src;
+
+  g_return_if_fail (GST_IS_SCHRO_ENC (object));
+  src = GST_SCHRO_ENC (object);
+
+  if (prop_id >= 1) {
+    const SchroEncoderSetting *setting;
+    setting = schro_encoder_get_setting_info (prop_id - 1);
+    switch (G_VALUE_TYPE (value)) {
+      case G_TYPE_DOUBLE:
+        g_value_set_double (value,
+            schro_encoder_setting_get_double (src->encoder, setting->name));
+        break;
+      case G_TYPE_INT:
+        g_value_set_int (value,
+            schro_encoder_setting_get_double (src->encoder, setting->name));
+        break;
+      case G_TYPE_BOOLEAN:
+        g_value_set_boolean (value,
+            schro_encoder_setting_get_double (src->encoder, setting->name));
+        break;
+      default:
+        /* it's an enum */
+        g_value_set_enum (value,
+            schro_encoder_setting_get_double (src->encoder, setting->name));
+        break;
+    }
+  }
+}
+
+static gboolean
+gst_schro_enc_start (GstBaseVideoEncoder * base_video_encoder)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  schro_enc->granule_offset = ~0;
+
+  return TRUE;
+}
+
+static gboolean
+gst_schro_enc_stop (GstBaseVideoEncoder * base_video_encoder)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  if (schro_enc->encoder) {
+    schro_encoder_free (schro_enc->encoder);
+    schro_enc->encoder = NULL;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_schro_enc_finish (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  GST_DEBUG ("finish");
+
+  schro_enc->eos_frame = frame;
+
+  schro_encoder_end_of_stream (schro_enc->encoder);
+  gst_schro_enc_process (schro_enc);
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_schro_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+  SchroFrame *schro_frame;
+  GstFlowReturn ret;
+  const GstVideoState *state;
+
+  state = gst_base_video_encoder_get_state (base_video_encoder);
+
+  if (schro_enc->granule_offset == ~0LL) {
+    schro_enc->granule_offset =
+        gst_util_uint64_scale (frame->presentation_timestamp,
+        2 * state->fps_n, GST_SECOND * state->fps_d);
+    GST_DEBUG ("granule offset %" G_GINT64_FORMAT, schro_enc->granule_offset);
+  }
+
+  schro_frame = gst_schro_buffer_wrap (gst_buffer_ref (frame->sink_buffer),
+      state->format, state->width, state->height);
+
+  GST_DEBUG ("pushing frame %p", frame);
+  schro_encoder_push_frame_full (schro_enc->encoder, schro_frame, frame);
+
+  ret = gst_schro_enc_process (schro_enc);
+
+  return ret;
+}
+
+#if 0
+static void
+gst_caps_add_streamheader (GstCaps * caps, GList * list)
+{
+  GValue array = { 0 };
+  GValue value = { 0 };
+  GstBuffer *buf;
+  GList *g;
+
+  g_value_init (&array, GST_TYPE_ARRAY);
+
+  for (g = g_list_first (list); g; g = g_list_next (list)) {
+    g_value_init (&value, GST_TYPE_BUFFER);
+    buf = gst_buffer_copy (GST_BUFFER (g->data));
+    gst_value_set_buffer (&value, buf);
+    gst_buffer_unref (buf);
+    gst_value_array_append_value (&array, &value);
+    g_value_unset (&value);
+  }
+  gst_structure_set_value (gst_caps_get_structure (caps, 0),
+      "streamheader", &array);
+  g_value_unset (&array);
+}
+#endif
+
+static GstCaps *
+gst_schro_enc_get_caps (GstBaseVideoEncoder * base_video_encoder)
+{
+  GstCaps *caps;
+  const GstVideoState *state;
+  GstSchroEnc *schro_enc;
+
+  schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  state = gst_base_video_encoder_get_state (base_video_encoder);
+
+  if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_OGG) {
+    caps = gst_caps_new_simple ("video/x-dirac",
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+
+    GST_BUFFER_FLAG_SET (schro_enc->seq_header_buffer, GST_BUFFER_FLAG_IN_CAPS);
+
+    {
+      GValue array = { 0 };
+      GValue value = { 0 };
+      GstBuffer *buf;
+      int size;
+
+      g_value_init (&array, GST_TYPE_ARRAY);
+      g_value_init (&value, GST_TYPE_BUFFER);
+      size = GST_BUFFER_SIZE (schro_enc->seq_header_buffer);
+      buf = gst_buffer_new_and_alloc (size + SCHRO_PARSE_HEADER_SIZE);
+
+      /* ogg(mux) expects the header buffers to have 0 timestamps -
+         set OFFSET and OFFSET_END accordingly */
+      GST_BUFFER_OFFSET (buf) = 0;
+      GST_BUFFER_OFFSET_END (buf) = 0;
+      GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_IN_CAPS);
+
+      memcpy (GST_BUFFER_DATA (buf),
+          GST_BUFFER_DATA (schro_enc->seq_header_buffer), size);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 0, 0x42424344);
+      GST_WRITE_UINT8 (GST_BUFFER_DATA (buf) + size + 4,
+          SCHRO_PARSE_CODE_END_OF_SEQUENCE);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 5, 0);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 9, size);
+      gst_value_set_buffer (&value, buf);
+      gst_buffer_unref (buf);
+      gst_value_array_append_value (&array, &value);
+      gst_structure_set_value (gst_caps_get_structure (caps, 0),
+          "streamheader", &array);
+      g_value_unset (&value);
+      g_value_unset (&array);
+    }
+  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_QUICKTIME) {
+    caps = gst_caps_new_simple ("video/x-qt-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_AVI) {
+    caps = gst_caps_new_simple ("video/x-avi-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_MPEG_TS) {
+    caps = gst_caps_new_simple ("video/x-mpegts-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_MP4) {
+    caps = gst_caps_new_simple ("video/x-mp4-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else {
+    g_assert_not_reached ();
+  }
+
+  return caps;
+}
+
+
+
+
+static GstFlowReturn
+gst_schro_enc_shape_output_ogg (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstSchroEnc *schro_enc;
+  int dpn;
+  int delay;
+  int dist;
+  int pt;
+  int dt;
+  guint64 granulepos_hi;
+  guint64 granulepos_low;
+  GstBuffer *buf = frame->src_buffer;
+
+  schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  dpn = frame->decode_frame_number;
+
+  pt = frame->presentation_frame_number * 2 + schro_enc->granule_offset;
+  dt = frame->decode_frame_number * 2 + schro_enc->granule_offset;
+  delay = pt - dt;
+  dist = frame->distance_from_sync;
+
+  GST_DEBUG ("sys %d dpn %d pt %d dt %d delay %d dist %d",
+      (int) frame->system_frame_number,
+      (int) frame->decode_frame_number, pt, dt, delay, dist);
+
+  granulepos_hi = (((guint64) pt - delay) << 9) | ((dist >> 8));
+  granulepos_low = (delay << 9) | (dist & 0xff);
+  GST_DEBUG ("granulepos %" G_GINT64_FORMAT ":%" G_GINT64_FORMAT, granulepos_hi,
+      granulepos_low);
+
+  if (frame->is_eos) {
+    GST_BUFFER_OFFSET_END (buf) = schro_enc->last_granulepos;
+  } else {
+    schro_enc->last_granulepos = (granulepos_hi << 22) | (granulepos_low);
+    GST_BUFFER_OFFSET_END (buf) = schro_enc->last_granulepos;
+  }
+
+  gst_buffer_set_caps (buf, base_video_encoder->caps);
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
+}
+
+static GstFlowReturn
+gst_schro_enc_shape_output_quicktime (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstBuffer *buf = frame->src_buffer;
+  const GstVideoState *state;
+
+  state = gst_base_video_encoder_get_state (base_video_encoder);
+
+  GST_BUFFER_TIMESTAMP (buf) = gst_video_state_get_timestamp (state,
+      frame->presentation_frame_number);
+  GST_BUFFER_DURATION (buf) = gst_video_state_get_timestamp (state,
+      frame->presentation_frame_number + 1) - GST_BUFFER_TIMESTAMP (buf);
+  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
+      frame->system_frame_number);
+  GST_BUFFER_OFFSET (buf) = GST_CLOCK_TIME_NONE;
+
+  if (frame->is_sync_point &&
+      frame->presentation_frame_number == frame->system_frame_number) {
+    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  gst_buffer_set_caps (buf, base_video_encoder->caps);
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
+}
+
+static GstFlowReturn
+gst_schro_enc_shape_output_mp4 (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstBuffer *buf = frame->src_buffer;
+  const GstVideoState *state;
+
+  state = gst_base_video_encoder_get_state (base_video_encoder);
+
+  GST_BUFFER_TIMESTAMP (buf) = gst_video_state_get_timestamp (state,
+      frame->presentation_frame_number);
+  GST_BUFFER_DURATION (buf) = gst_video_state_get_timestamp (state,
+      frame->presentation_frame_number + 1) - GST_BUFFER_TIMESTAMP (buf);
+  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
+      frame->decode_frame_number);
+  GST_BUFFER_OFFSET (buf) = GST_CLOCK_TIME_NONE;
+
+  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
+      frame->system_frame_number);
+
+  if (frame->is_sync_point &&
+      frame->presentation_frame_number == frame->system_frame_number) {
+    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  gst_buffer_set_caps (buf, base_video_encoder->caps);
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
+}
+
+static GstFlowReturn
+gst_schro_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstSchroEnc *schro_enc;
+
+  schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  switch (schro_enc->output_format) {
+    case GST_SCHRO_ENC_OUTPUT_OGG:
+      return gst_schro_enc_shape_output_ogg (base_video_encoder, frame);
+    case GST_SCHRO_ENC_OUTPUT_QUICKTIME:
+      return gst_schro_enc_shape_output_quicktime (base_video_encoder, frame);
+    case GST_SCHRO_ENC_OUTPUT_MP4:
+      return gst_schro_enc_shape_output_mp4 (base_video_encoder, frame);
+    default:
+      g_assert_not_reached ();
+      break;
+  }
+
+  return GST_FLOW_ERROR;
+}
+
+static GstFlowReturn
+gst_schro_enc_process (GstSchroEnc * schro_enc)
+{
+  SchroBuffer *encoded_buffer;
+  GstVideoFrame *frame;
+  GstFlowReturn ret;
+  int presentation_frame;
+  void *voidptr;
+  GstBaseVideoEncoder *base_video_encoder = GST_BASE_VIDEO_ENCODER (schro_enc);
+
+  GST_DEBUG ("process");
+
+  while (1) {
+    switch (schro_encoder_wait (schro_enc->encoder)) {
+      case SCHRO_STATE_NEED_FRAME:
+        return GST_FLOW_OK;
+      case SCHRO_STATE_END_OF_STREAM:
+        GST_DEBUG ("EOS");
+        return GST_FLOW_OK;
+      case SCHRO_STATE_HAVE_BUFFER:
+        voidptr = NULL;
+        encoded_buffer = schro_encoder_pull_full (schro_enc->encoder,
+            &presentation_frame, &voidptr);
+        frame = voidptr;
+        if (encoded_buffer == NULL) {
+          GST_DEBUG ("encoder_pull returned NULL");
+          /* FIXME This shouldn't happen */
+          return GST_FLOW_ERROR;
+        }
+
+        if (voidptr == NULL) {
+          GST_DEBUG ("got eos");
+          frame = schro_enc->eos_frame;
+        }
+
+        if (SCHRO_PARSE_CODE_IS_SEQ_HEADER (encoded_buffer->data[4])) {
+          frame->is_sync_point = TRUE;
+        }
+
+        frame->src_buffer = gst_schro_wrap_schro_buffer (encoded_buffer);
+
+        ret = gst_base_video_encoder_finish_frame (base_video_encoder, frame);
+
+        if (ret != GST_FLOW_OK) {
+          GST_DEBUG ("pad_push returned %d", ret);
+          return ret;
+        }
+        break;
+      case SCHRO_STATE_AGAIN:
+        break;
+    }
+  }
+  return GST_FLOW_OK;
+}
diff -uNr schroedinger-1.0.8.orig/gst/gstschroparse.c schroedinger-1.0.8/gst/gstschroparse.c
--- schroedinger-1.0.8.orig/gst/gstschroparse.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst/gstschroparse.c	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,610 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+#include <gst/video/video.h>
+#include <gst/video/gstbasevideoparse.h>
+#include <string.h>
+#include <schroedinger/schro.h>
+#include <math.h>
+
+#include <schroedinger/schroparse.h>
+
+
+GST_DEBUG_CATEGORY_EXTERN (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+#define GST_TYPE_SCHRO_PARSE \
+  (gst_schro_parse_get_type())
+#define GST_SCHRO_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SCHRO_PARSE,GstSchroParse))
+#define GST_SCHRO_PARSE_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SCHRO_PARSE,GstSchroParseClass))
+#define GST_IS_SCHRO_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SCHRO_PARSE))
+#define GST_IS_SCHRO_PARSE_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SCHRO_PARSE))
+
+typedef struct _GstSchroParse GstSchroParse;
+typedef struct _GstSchroParseClass GstSchroParseClass;
+
+typedef enum
+{
+  GST_SCHRO_PARSE_OUTPUT_OGG,
+  GST_SCHRO_PARSE_OUTPUT_QUICKTIME,
+  GST_SCHRO_PARSE_OUTPUT_AVI,
+  GST_SCHRO_PARSE_OUTPUT_MPEG_TS,
+  GST_SCHRO_PARSE_OUTPUT_MP4
+} GstSchroParseOutputType;
+
+struct _GstSchroParse
+{
+  GstBaseVideoParse base_video_parse;
+
+  GstPad *sinkpad, *srcpad;
+
+  GstSchroParseOutputType output_format;
+
+  GstBuffer *seq_header_buffer;
+
+  /* state */
+
+
+  gboolean have_picture;
+  int buf_picture_number;
+  int seq_hdr_picture_number;
+  int picture_number;
+
+  guint64 last_granulepos;
+
+  int bytes_per_picture;
+};
+
+struct _GstSchroParseClass
+{
+  GstBaseVideoParseClass base_video_parse_class;
+};
+
+/* GstSchroParse signals and args */
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_schro_parse_finalize (GObject * object);
+
+static gboolean gst_schro_parse_start (GstBaseVideoParse * base_video_parse);
+static gboolean gst_schro_parse_stop (GstBaseVideoParse * base_video_parse);
+static gboolean gst_schro_parse_reset (GstBaseVideoParse * base_video_parse);
+static int gst_schro_parse_scan_for_sync (GstAdapter * adapter,
+    gboolean at_eos, int offset, int n);
+static gboolean gst_schro_parse_parse_data (GstBaseVideoParse *
+    base_video_parse, gboolean at_eos);
+static gboolean gst_schro_parse_shape_output (GstBaseVideoParse *
+    base_video_parse, GstVideoFrame * frame);
+static GstCaps *gst_schro_parse_get_caps (GstBaseVideoParse * base_video_parse);
+
+
+
+static GstStaticPadTemplate gst_schro_parse_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-dirac")
+    );
+
+static GstStaticPadTemplate gst_schro_parse_src_template =
+    GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS
+    ("video/x-dirac;video/x-qt-part;video/x-avi-part;video/x-mp4-part")
+    );
+
+GST_BOILERPLATE (GstSchroParse, gst_schro_parse, GstBaseVideoParse,
+    GST_TYPE_BASE_VIDEO_PARSE);
+
+static void
+gst_schro_parse_base_init (gpointer g_class)
+{
+  static GstElementDetails compress_details =
+      GST_ELEMENT_DETAILS ("Dirac Parser",
+      "Codec/Parser/Video",
+      "Parse Dirac streams",
+      "David Schleef <ds@schleef.org>");
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_parse_src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_parse_sink_template));
+
+  gst_element_class_set_details (element_class, &compress_details);
+}
+
+static void
+gst_schro_parse_class_init (GstSchroParseClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+  GstBaseVideoParseClass *base_video_parse_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+  base_video_parse_class = GST_BASE_VIDEO_PARSE_CLASS (klass);
+
+  gobject_class->finalize = gst_schro_parse_finalize;
+
+  base_video_parse_class->start = GST_DEBUG_FUNCPTR (gst_schro_parse_start);
+  base_video_parse_class->stop = GST_DEBUG_FUNCPTR (gst_schro_parse_stop);
+  base_video_parse_class->reset = GST_DEBUG_FUNCPTR (gst_schro_parse_reset);
+  base_video_parse_class->parse_data =
+      GST_DEBUG_FUNCPTR (gst_schro_parse_parse_data);
+  base_video_parse_class->shape_output =
+      GST_DEBUG_FUNCPTR (gst_schro_parse_shape_output);
+  base_video_parse_class->scan_for_sync =
+      GST_DEBUG_FUNCPTR (gst_schro_parse_scan_for_sync);
+  base_video_parse_class->get_caps =
+      GST_DEBUG_FUNCPTR (gst_schro_parse_get_caps);
+
+}
+
+static void
+gst_schro_parse_init (GstSchroParse * schro_parse, GstSchroParseClass * klass)
+{
+  GstBaseVideoParse *base_video_parse = GST_BASE_VIDEO_PARSE (schro_parse);
+
+  GST_DEBUG ("gst_schro_parse_init");
+
+  schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_OGG;
+
+  base_video_parse->reorder_depth = 2;
+}
+
+static gboolean
+gst_schro_parse_reset (GstBaseVideoParse * base_video_parse)
+{
+  GstSchroParse *schro_parse;
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  GST_DEBUG ("reset");
+
+  return TRUE;
+}
+
+static void
+gst_schro_parse_finalize (GObject * object)
+{
+  GstSchroParse *schro_parse;
+
+  g_return_if_fail (GST_IS_SCHRO_PARSE (object));
+  schro_parse = GST_SCHRO_PARSE (object);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_schro_parse_start (GstBaseVideoParse * base_video_parse)
+{
+  GstSchroParse *schro_parse = GST_SCHRO_PARSE (base_video_parse);
+  GstCaps *caps;
+  GstStructure *structure;
+
+  GST_DEBUG ("start");
+  caps =
+      gst_pad_get_allowed_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
+      (base_video_parse));
+
+  if (gst_caps_is_empty (caps)) {
+    gst_caps_unref (caps);
+    return FALSE;
+  }
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  if (gst_structure_has_name (structure, "video/x-dirac")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_OGG;
+  } else if (gst_structure_has_name (structure, "video/x-qt-part")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_QUICKTIME;
+  } else if (gst_structure_has_name (structure, "video/x-avi-part")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_AVI;
+  } else if (gst_structure_has_name (structure, "video/x-mpegts-part")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_MPEG_TS;
+  } else if (gst_structure_has_name (structure, "video/x-mp4-part")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_MP4;
+  } else {
+    return FALSE;
+  }
+
+  gst_caps_unref (caps);
+  return TRUE;
+}
+
+static gboolean
+gst_schro_parse_stop (GstBaseVideoParse * base_video_parse)
+{
+  return TRUE;
+}
+
+static void
+parse_sequence_header (GstSchroParse * schro_parse, guint8 * data, int size)
+{
+  SchroVideoFormat video_format;
+  int ret;
+  GstVideoState *state;
+
+  GST_DEBUG ("parse_sequence_header size=%d", size);
+
+  state = gst_base_video_parse_get_state (GST_BASE_VIDEO_PARSE (schro_parse));
+
+  schro_parse->seq_header_buffer = gst_buffer_new_and_alloc (size);
+  memcpy (GST_BUFFER_DATA (schro_parse->seq_header_buffer), data, size);
+
+  ret = schro_parse_decode_sequence_header (data + 13, size - 13,
+      &video_format);
+  if (ret) {
+    state->fps_n = video_format.frame_rate_numerator;
+    state->fps_d = video_format.frame_rate_denominator;
+    GST_DEBUG ("Frame rate is %d/%d", state->fps_n, state->fps_d);
+
+    state->width = video_format.width;
+    state->height = video_format.height;
+    GST_DEBUG ("Frame dimensions are %d x %d\n", state->width, state->height);
+
+    state->clean_width = video_format.clean_width;
+    state->clean_height = video_format.clean_height;
+    state->clean_offset_left = video_format.left_offset;
+    state->clean_offset_top = video_format.top_offset;
+
+    state->par_n = video_format.aspect_ratio_numerator;
+    state->par_d = video_format.aspect_ratio_denominator;
+    GST_DEBUG ("Pixel aspect ratio is %d/%d", state->par_n, state->par_d);
+
+    gst_base_video_parse_set_state (GST_BASE_VIDEO_PARSE (schro_parse), state);
+  } else {
+    GST_WARNING ("Failed to get frame rate from sequence header");
+  }
+
+}
+
+static int
+gst_schro_parse_scan_for_sync (GstAdapter * adapter, gboolean at_eos,
+    int offset, int n)
+{
+  int n_available = gst_adapter_available (adapter) - offset;
+
+  if (n_available < 4) {
+    if (at_eos) {
+      return n_available;
+    } else {
+      return 0;
+    }
+  }
+
+  n_available -= 3;
+
+  return gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x42424344,
+      offset, MIN (n, n_available - 3));
+}
+
+static GstFlowReturn
+gst_schro_parse_parse_data (GstBaseVideoParse * base_video_parse,
+    gboolean at_eos)
+{
+  GstSchroParse *schro_parse;
+  unsigned char header[SCHRO_PARSE_HEADER_SIZE];
+  int next;
+  int prev;
+  int parse_code;
+
+  GST_DEBUG ("parse_data");
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  if (gst_adapter_available (base_video_parse->input_adapter) <
+      SCHRO_PARSE_HEADER_SIZE) {
+    return GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA;
+  }
+
+  GST_DEBUG ("available %d",
+      gst_adapter_available (base_video_parse->input_adapter));
+
+  gst_adapter_copy (base_video_parse->input_adapter, header, 0,
+      SCHRO_PARSE_HEADER_SIZE);
+
+  parse_code = header[4];
+  next = GST_READ_UINT32_BE (header + 5);
+  prev = GST_READ_UINT32_BE (header + 9);
+
+  GST_DEBUG ("%08x %02x %08x %08x",
+      GST_READ_UINT32_BE (header), parse_code, next, prev);
+
+  if (memcmp (header, "BBCD", 4) != 0 ||
+      (next & 0xf0000000) || (prev & 0xf0000000)) {
+    gst_base_video_parse_lost_sync (base_video_parse);
+    return GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE (parse_code)) {
+    GstVideoFrame *frame;
+
+    if (next != 0 && next != SCHRO_PARSE_HEADER_SIZE) {
+      GST_WARNING ("next is not 0 or 13 in EOS packet (%d)", next);
+    }
+
+    gst_base_video_parse_add_to_frame (base_video_parse,
+        SCHRO_PARSE_HEADER_SIZE);
+
+    frame = gst_base_video_parse_get_frame (base_video_parse);
+    frame->is_eos = TRUE;
+
+    SCHRO_DEBUG ("eos");
+
+    return gst_base_video_parse_finish_frame (base_video_parse);
+  }
+
+  if (gst_adapter_available (base_video_parse->input_adapter) < next) {
+    return GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_SEQ_HEADER (parse_code)) {
+    guint8 *data;
+
+    data = g_malloc (next);
+
+    gst_adapter_copy (base_video_parse->input_adapter, data, 0, next);
+    parse_sequence_header (schro_parse, data, next);
+
+    base_video_parse->current_frame->is_sync_point = TRUE;
+
+    g_free (data);
+  }
+
+  if (schro_parse->seq_header_buffer == NULL) {
+    gst_adapter_flush (base_video_parse->input_adapter, next);
+    return GST_FLOW_OK;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_PICTURE (parse_code)) {
+    GstVideoFrame *frame;
+    guint8 tmp[4];
+
+    frame = gst_base_video_parse_get_frame (base_video_parse);
+
+#if 0
+    if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_TIMESTAMP (buf))) {
+      frame->presentation_timestamp = GST_BUFFER_TIMESTAMP (buf);
+    }
+#endif
+
+    gst_adapter_copy (base_video_parse->input_adapter, tmp,
+        SCHRO_PARSE_HEADER_SIZE, 4);
+
+    frame->presentation_frame_number = GST_READ_UINT32_BE (tmp);
+
+    gst_base_video_parse_add_to_frame (base_video_parse, next);
+
+    return gst_base_video_parse_finish_frame (base_video_parse);
+  } else {
+    gst_base_video_parse_add_to_frame (base_video_parse, next);
+  }
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+gst_schro_parse_shape_output_ogg (GstBaseVideoParse * base_video_parse,
+    GstVideoFrame * frame)
+{
+  GstSchroParse *schro_parse;
+  int dpn;
+  int delay;
+  int dist;
+  int pt;
+  int dt;
+  guint64 granulepos_hi;
+  guint64 granulepos_low;
+  GstBuffer *buf = frame->src_buffer;
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  dpn = frame->decode_frame_number;
+
+  pt = frame->presentation_frame_number * 2;
+  dt = frame->decode_frame_number * 2;
+  delay = pt - dt;
+  dist = frame->distance_from_sync;
+
+  GST_DEBUG ("sys %d dpn %d pt %d dt %d delay %d dist %d",
+      (int) frame->system_frame_number,
+      (int) frame->decode_frame_number, pt, dt, delay, dist);
+
+  granulepos_hi = (((guint64) pt - delay) << 9) | ((dist >> 8));
+  granulepos_low = (delay << 9) | (dist & 0xff);
+  GST_DEBUG ("granulepos %" G_GINT64_FORMAT ":%" G_GINT64_FORMAT, granulepos_hi,
+      granulepos_low);
+
+  if (frame->is_eos) {
+    GST_BUFFER_OFFSET_END (buf) = schro_parse->last_granulepos;
+  } else {
+    schro_parse->last_granulepos = (granulepos_hi << 22) | (granulepos_low);
+    GST_BUFFER_OFFSET_END (buf) = schro_parse->last_granulepos;
+  }
+
+  return gst_base_video_parse_push (base_video_parse, buf);
+}
+
+static GstFlowReturn
+gst_schro_parse_shape_output_quicktime (GstBaseVideoParse * base_video_parse,
+    GstVideoFrame * frame)
+{
+  GstBuffer *buf = frame->src_buffer;
+  const GstVideoState *state;
+
+  state = gst_base_video_parse_get_state (base_video_parse);
+
+  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
+      frame->system_frame_number);
+
+  if (frame->is_sync_point &&
+      frame->presentation_frame_number == frame->system_frame_number) {
+    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+    GST_DEBUG ("sync point");
+  } else {
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  return gst_base_video_parse_push (base_video_parse, buf);
+}
+
+static GstFlowReturn
+gst_schro_parse_shape_output_mpeg_ts (GstBaseVideoParse * base_video_parse,
+    GstVideoFrame * frame)
+{
+  GstBuffer *buf = frame->src_buffer;
+  const GstVideoState *state;
+
+  state = gst_base_video_parse_get_state (base_video_parse);
+
+  return gst_base_video_parse_push (base_video_parse, buf);
+}
+
+static GstFlowReturn
+gst_schro_parse_shape_output (GstBaseVideoParse * base_video_parse,
+    GstVideoFrame * frame)
+{
+  GstSchroParse *schro_parse;
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  switch (schro_parse->output_format) {
+    case GST_SCHRO_PARSE_OUTPUT_OGG:
+      return gst_schro_parse_shape_output_ogg (base_video_parse, frame);
+    case GST_SCHRO_PARSE_OUTPUT_QUICKTIME:
+      return gst_schro_parse_shape_output_quicktime (base_video_parse, frame);
+    case GST_SCHRO_PARSE_OUTPUT_MPEG_TS:
+      return gst_schro_parse_shape_output_mpeg_ts (base_video_parse, frame);
+    default:
+      break;
+  }
+
+  return GST_FLOW_ERROR;
+}
+
+static GstCaps *
+gst_schro_parse_get_caps (GstBaseVideoParse * base_video_parse)
+{
+  GstCaps *caps;
+  GstVideoState *state;
+  GstSchroParse *schro_parse;
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  state = gst_base_video_parse_get_state (base_video_parse);
+
+  if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_OGG) {
+    caps = gst_caps_new_simple ("video/x-dirac",
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+
+    GST_BUFFER_FLAG_SET (schro_parse->seq_header_buffer,
+        GST_BUFFER_FLAG_IN_CAPS);
+
+    {
+      GValue array = { 0 };
+      GValue value = { 0 };
+      GstBuffer *buf;
+      int size;
+
+      g_value_init (&array, GST_TYPE_ARRAY);
+      g_value_init (&value, GST_TYPE_BUFFER);
+      size = GST_BUFFER_SIZE (schro_parse->seq_header_buffer);
+      buf = gst_buffer_new_and_alloc (size + SCHRO_PARSE_HEADER_SIZE);
+      memcpy (GST_BUFFER_DATA (buf),
+          GST_BUFFER_DATA (schro_parse->seq_header_buffer), size);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 0, 0x42424344);
+      GST_WRITE_UINT8 (GST_BUFFER_DATA (buf) + size + 4,
+          SCHRO_PARSE_CODE_END_OF_SEQUENCE);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 5, 0);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 9, size);
+      gst_value_set_buffer (&value, buf);
+      gst_buffer_unref (buf);
+      gst_value_array_append_value (&array, &value);
+      gst_structure_set_value (gst_caps_get_structure (caps, 0),
+          "streamheader", &array);
+      g_value_unset (&value);
+      g_value_unset (&array);
+    }
+  } else if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_QUICKTIME) {
+    caps = gst_caps_new_simple ("video/x-qt-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_AVI) {
+    caps = gst_caps_new_simple ("video/x-avi-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_MPEG_TS) {
+    caps = gst_caps_new_simple ("video/x-mpegts-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_MP4) {
+    caps = gst_caps_new_simple ("video/x-mp4-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else {
+    g_assert_not_reached ();
+  }
+
+  return caps;
+}
diff -uNr schroedinger-1.0.8.orig/gst/gstschroutils.c schroedinger-1.0.8/gst/gstschroutils.c
--- schroedinger-1.0.8.orig/gst/gstschroutils.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst/gstschroutils.c	2009-09-11 17:35:39.000000000 +0200
@@ -0,0 +1,149 @@
+/* Schrodinger
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+//#define SCHRO_ENABLE_UNSTABLE_API
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <schroedinger/schro.h>
+#include <schroedinger/schrobitstream.h>
+#include <schroedinger/schrovirtframe.h>
+#include <math.h>
+#include <string.h>
+
+GST_DEBUG_CATEGORY_EXTERN (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+
+
+
+static void
+gst_schro_frame_free (SchroFrame * frame, void *priv)
+{
+  gst_buffer_unref (GST_BUFFER (priv));
+}
+
+SchroFrame *
+gst_schro_buffer_wrap (GstBuffer * buf, GstVideoFormat format, int width,
+    int height)
+{
+  SchroFrame *frame;
+
+  switch (format) {
+    case GST_VIDEO_FORMAT_I420:
+      frame =
+          schro_frame_new_from_data_I420 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_YV12:
+      frame =
+          schro_frame_new_from_data_YV12 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_YUY2:
+      frame =
+          schro_frame_new_from_data_YUY2 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_UYVY:
+      frame =
+          schro_frame_new_from_data_UYVY (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_AYUV:
+      frame =
+          schro_frame_new_from_data_AYUV (GST_BUFFER_DATA (buf), width, height);
+      break;
+#if 0
+    case GST_VIDEO_FORMAT_ARGB:
+    {
+      SchroFrame *rgbframe =
+          schro_frame_new_from_data_AYUV (GST_BUFFER_DATA (buf), width, height);
+      SchroFrame *vframe1;
+      SchroFrame *vframe2;
+      SchroFrame *vframe3;
+
+      vframe1 = schro_virt_frame_new_unpack (rgbframe);
+      vframe2 = schro_virt_frame_new_color_matrix (vframe1);
+      vframe3 =
+          schro_virt_frame_new_subsample (vframe2, SCHRO_FRAME_FORMAT_U8_420);
+
+      frame = schro_frame_new_and_alloc (NULL, SCHRO_FRAME_FORMAT_U8_420,
+          width, height);
+      schro_virt_frame_render (vframe3, frame);
+      schro_frame_unref (vframe3);
+    }
+      break;
+#endif
+    default:
+      g_assert_not_reached ();
+  }
+  schro_frame_set_free_callback (frame, gst_schro_frame_free, buf);
+
+  return frame;
+}
+
+#ifdef GST_BUFFER_FREE_FUNC
+static void
+schro_buf_free_func (gpointer priv)
+{
+  SchroBuffer *buffer = (SchroBuffer *) priv;
+
+  schro_buffer_unref (buffer);
+}
+#endif
+
+/* takes the reference */
+GstBuffer *
+gst_schro_wrap_schro_buffer (SchroBuffer * buffer)
+{
+  GstBuffer *gstbuf;
+
+#ifdef GST_BUFFER_FREE_FUNC
+  gstbuf = gst_buffer_new ();
+  GST_BUFFER_DATA (gstbuf) = buffer->data;
+  GST_BUFFER_SIZE (gstbuf) = buffer->length;
+  GST_BUFFER_MALLOCDATA (gstbuf) = (void *) buffer;
+  GST_BUFFER_FREE_FUNC (gstbuf) = schro_buf_free_func;
+#else
+  gstbuf = gst_buffer_new_and_alloc (buffer->length);
+  memcpy (GST_BUFFER_DATA (gstbuf), buffer->data, buffer->length);
+#endif
+
+  return gstbuf;
+}
+
+static void
+gst_schro_buffer_free (SchroBuffer * buffer, void *priv)
+{
+  gst_buffer_unref (GST_BUFFER (priv));
+}
+
+SchroBuffer *
+gst_schro_wrap_gst_buffer (GstBuffer * buffer)
+{
+  SchroBuffer *schrobuf;
+
+  schrobuf = schro_buffer_new_with_data (GST_BUFFER_DATA (buffer),
+      GST_BUFFER_SIZE (buffer));
+  schrobuf->free = gst_schro_buffer_free;
+  schrobuf->priv = buffer;
+
+  return schrobuf;
+}
diff -uNr schroedinger-1.0.8.orig/gst/gstschroutils.h schroedinger-1.0.8/gst/gstschroutils.h
--- schroedinger-1.0.8.orig/gst/gstschroutils.h	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst/gstschroutils.h	2009-09-11 17:35:39.000000000 +0200
@@ -0,0 +1,34 @@
+/* Schrodinger
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_SCHRO_UTILS_H_
+#define _GST_SCHRO_UTILS_H_
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <schroedinger/schro.h>
+
+SchroFrame *
+gst_schro_buffer_wrap (GstBuffer *buf, GstVideoFormat format, int width,
+    int height);
+GstBuffer * gst_schro_wrap_schro_buffer (SchroBuffer *buffer);
+SchroBuffer * gst_schro_wrap_gst_buffer (GstBuffer *buffer);
+
+#endif
+
diff -uNr schroedinger-1.0.8.orig/gst/Makefile.am schroedinger-1.0.8/gst/Makefile.am
--- schroedinger-1.0.8.orig/gst/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst/Makefile.am	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,27 @@
+
+plugin_LTLIBRARIES = libgstschro.la
+
+noinst_HEADERS = \
+	gstschroutils.h
+
+libgstschro_la_SOURCES = \
+	gstschro.c \
+	gstschrodec.c \
+	gstschroenc.c \
+	gstschroparse.c \
+	gstschroutils.c
+libgstschro_la_CFLAGS = \
+	$(GST_CFLAGS) \
+	$(GST_PLUGINS_BASE_CFLAGS) \
+        $(GST_BASE_CFLAGS) \
+	-DGST_USE_UNSTABLE_API \
+	$(SCHRO_CFLAGS) -I$(top_srcdir)/gst-libs
+libgstschro_la_LIBADD = \
+	$(top_builddir)/gst-libs/gst/video/libgstbasevideo-@GST_MAJORMINOR@.la \
+	$(GST_PLUGINS_BASE_LIBS) -lgstvideo-@GST_MAJORMINOR@ \
+        $(GST_BASE_LIBS) $(GST_LIBS) \
+	$(SCHRO_LIBS)
+libgstschro_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstschro_la_LIBTOOLFLAGS = --tag=disable-static
+
+
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideocodec.c schroedinger-1.0.8/gst-libs/gst/video/gstbasevideocodec.c
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideocodec.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideocodec.c	2009-09-11 17:35:39.000000000 +0200
@@ -0,0 +1,565 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideocodec.h"
+
+#include <string.h>
+#include <math.h>
+
+GST_DEBUG_CATEGORY (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+/* GstBaseVideoCodec signals and args */
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_base_video_codec_finalize (GObject * object);
+
+static GstStateChangeReturn gst_base_video_codec_change_state (GstElement *
+    element, GstStateChange transition);
+
+
+GST_BOILERPLATE (GstBaseVideoCodec, gst_base_video_codec, GstElement,
+    GST_TYPE_ELEMENT);
+
+static void
+gst_base_video_codec_base_init (gpointer g_class)
+{
+  GST_DEBUG_CATEGORY_INIT (basevideo_debug, "basevideo", 0,
+      "Base Video Classes");
+
+}
+
+static void
+gst_base_video_codec_class_init (GstBaseVideoCodecClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->finalize = gst_base_video_codec_finalize;
+
+  element_class->change_state = gst_base_video_codec_change_state;
+}
+
+static void
+gst_base_video_codec_init (GstBaseVideoCodec * base_video_codec,
+    GstBaseVideoCodecClass * klass)
+{
+  GstPadTemplate *pad_template;
+
+  GST_DEBUG ("gst_base_video_codec_init");
+
+  pad_template =
+      gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), "sink");
+  g_return_if_fail (pad_template != NULL);
+
+  base_video_codec->sinkpad = gst_pad_new_from_template (pad_template, "sink");
+  gst_element_add_pad (GST_ELEMENT (base_video_codec),
+      base_video_codec->sinkpad);
+
+  pad_template =
+      gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), "src");
+  g_return_if_fail (pad_template != NULL);
+
+  base_video_codec->srcpad = gst_pad_new_from_template (pad_template, "src");
+  gst_pad_use_fixed_caps (base_video_codec->srcpad);
+  gst_element_add_pad (GST_ELEMENT (base_video_codec),
+      base_video_codec->srcpad);
+
+  base_video_codec->input_adapter = gst_adapter_new ();
+  base_video_codec->output_adapter = gst_adapter_new ();
+
+}
+
+static void
+gst_base_video_codec_reset (GstBaseVideoCodec * base_video_codec)
+{
+  GST_DEBUG ("reset");
+
+  base_video_codec->system_frame_number = 0;
+
+  gst_adapter_clear (base_video_codec->input_adapter);
+  gst_adapter_clear (base_video_codec->output_adapter);
+
+}
+
+static void
+gst_base_video_codec_finalize (GObject * object)
+{
+  GstBaseVideoCodec *base_video_codec;
+
+  g_return_if_fail (GST_IS_BASE_VIDEO_CODEC (object));
+  base_video_codec = GST_BASE_VIDEO_CODEC (object);
+
+  if (base_video_codec->input_adapter) {
+    g_object_unref (base_video_codec->input_adapter);
+  }
+  if (base_video_codec->output_adapter) {
+    g_object_unref (base_video_codec->output_adapter);
+  }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+#ifdef unused
+static const GstQueryType *
+gst_base_video_codec_get_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_POSITION,
+    GST_QUERY_DURATION,
+    GST_QUERY_CONVERT,
+    0
+  };
+
+  return query_types;
+}
+#endif
+
+#if 0
+static gboolean
+gst_base_video_codec_src_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res;
+  GstBaseVideoCodec *dec;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
+    if (dec->fps_d != 0) {
+      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+          dec->fps_d * GST_SECOND, dec->fps_n);
+      res = TRUE;
+    } else {
+      res = FALSE;
+    }
+  } else {
+    GST_WARNING ("unhandled conversion from %d to %d", src_format,
+        *dest_format);
+    res = FALSE;
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+
+static gboolean
+gst_base_video_codec_sink_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstBaseVideoCodec *dec;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a decoding state */
+
+  switch (src_format) {
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (src_value,
+              dec->fps_d * GST_SECOND, dec->fps_n);
+          break;
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_TIME:
+      switch (*dest_format) {
+        case GST_FORMAT_DEFAULT:
+        {
+          *dest_value = gst_util_uint64_scale (src_value,
+              dec->fps_n, dec->fps_d * GST_SECOND);
+          break;
+        }
+        default:
+          res = FALSE;
+          break;
+      }
+      break;
+    default:
+      res = FALSE;
+      break;
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+#endif
+
+#ifdef unused
+static gboolean
+gst_base_video_codec_src_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoCodec *base_codec;
+  gboolean res = FALSE;
+
+  base_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_POSITION:
+    {
+      GstFormat format;
+      gint64 time;
+      gint64 value;
+
+      gst_query_parse_position (query, &format, NULL);
+
+      time = gst_util_uint64_scale (base_codec->system_frame_number,
+          base_codec->state.fps_n, base_codec->state.fps_d);
+      time += base_codec->state.segment.time;
+      GST_DEBUG ("query position %lld", time);
+      res = gst_base_video_encoded_video_convert (&base_codec->state,
+          GST_FORMAT_TIME, time, &format, &value);
+      if (!res)
+        goto error;
+
+      gst_query_set_position (query, format, value);
+      break;
+    }
+    case GST_QUERY_DURATION:
+      res = gst_pad_query (GST_PAD_PEER (base_codec->sinkpad), query);
+      if (!res)
+        goto error;
+      break;
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      GST_DEBUG ("query convert");
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&base_codec->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_codec);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_codec, "query failed");
+  goto done;
+}
+#endif
+
+#ifdef unused
+static gboolean
+gst_base_video_codec_sink_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoCodec *base_video_codec;
+  gboolean res = FALSE;
+
+  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_video_codec);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_video_codec, "query failed");
+  goto done;
+}
+#endif
+
+#ifdef unused
+static gboolean
+gst_base_video_codec_src_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoCodec *base_video_codec;
+  gboolean res = FALSE;
+
+  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:
+    {
+      GstFormat format, tformat;
+      gdouble rate;
+      GstEvent *real_seek;
+      GstSeekFlags flags;
+      GstSeekType cur_type, stop_type;
+      gint64 cur, stop;
+      gint64 tcur, tstop;
+
+      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type,
+          &cur, &stop_type, &stop);
+      gst_event_unref (event);
+
+      tformat = GST_FORMAT_TIME;
+      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
+          format, cur, &tformat, &tcur);
+      if (!res)
+        goto convert_error;
+      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
+          format, stop, &tformat, &tstop);
+      if (!res)
+        goto convert_error;
+
+      real_seek = gst_event_new_seek (rate, GST_FORMAT_TIME,
+          flags, cur_type, tcur, stop_type, tstop);
+
+      res = gst_pad_push_event (base_video_codec->sinkpad, real_seek);
+
+      break;
+    }
+#if 0
+    case GST_EVENT_QOS:
+    {
+      gdouble proportion;
+      GstClockTimeDiff diff;
+      GstClockTime timestamp;
+
+      gst_event_parse_qos (event, &proportion, &diff, &timestamp);
+
+      GST_OBJECT_LOCK (base_video_codec);
+      base_video_codec->proportion = proportion;
+      base_video_codec->earliest_time = timestamp + diff;
+      GST_OBJECT_UNLOCK (base_video_codec);
+
+      GST_DEBUG_OBJECT (base_video_codec,
+          "got QoS %" GST_TIME_FORMAT ", %" G_GINT64_FORMAT,
+          GST_TIME_ARGS (timestamp), diff);
+
+      res = gst_pad_push_event (base_video_codec->sinkpad, event);
+      break;
+    }
+#endif
+    default:
+      res = gst_pad_push_event (base_video_codec->sinkpad, event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_codec);
+  return res;
+
+convert_error:
+  GST_DEBUG_OBJECT (base_video_codec, "could not convert format");
+  goto done;
+}
+#endif
+
+#ifdef unused
+static gboolean
+gst_base_video_codec_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoCodec *base_video_codec;
+  gboolean ret = FALSE;
+
+  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_START:
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      gst_base_video_codec_reset (base_video_codec);
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+    case GST_EVENT_EOS:
+      if (gst_base_video_codec_push_all (base_video_codec,
+              FALSE) == GST_FLOW_ERROR) {
+        gst_event_unref (event);
+        return FALSE;
+      }
+
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      gboolean update;
+      GstFormat format;
+      gdouble rate;
+      gint64 start, stop, time;
+
+      gst_event_parse_new_segment (event, &update, &rate, &format, &start,
+          &stop, &time);
+
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      if (rate <= 0.0)
+        goto newseg_wrong_rate;
+
+      GST_DEBUG ("newsegment %lld %lld", start, time);
+      gst_segment_set_newsegment (&base_video_codec->state.segment, update,
+          rate, format, start, stop, time);
+
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+    }
+    default:
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_codec);
+  return ret;
+
+newseg_wrong_format:
+  GST_DEBUG_OBJECT (base_video_codec, "received non TIME newsegment");
+  gst_event_unref (event);
+  goto done;
+
+newseg_wrong_rate:
+  GST_DEBUG_OBJECT (base_video_codec, "negative rates not supported");
+  gst_event_unref (event);
+  goto done;
+}
+#endif
+
+
+static GstStateChangeReturn
+gst_base_video_codec_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstBaseVideoCodec *base_video_codec = GST_BASE_VIDEO_CODEC (element);
+  GstStateChangeReturn ret;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_base_video_codec_reset (base_video_codec);
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      break;
+    default:
+      break;
+  }
+
+  ret = parent_class->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_base_video_codec_reset (base_video_codec);
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+#if 0
+guint64
+gst_base_video_codec_get_timestamp (GstBaseVideoCodec * base_video_codec,
+    int picture_number)
+{
+  if (picture_number < 0) {
+    return base_video_codec->timestamp_offset -
+        (gint64) gst_util_uint64_scale (-picture_number,
+        base_video_codec->state.fps_d * GST_SECOND,
+        base_video_codec->state.fps_n);
+  } else {
+    return base_video_codec->timestamp_offset +
+        gst_util_uint64_scale (picture_number,
+        base_video_codec->state.fps_d * GST_SECOND,
+        base_video_codec->state.fps_n);
+  }
+}
+#endif
+
+GstVideoFrame *
+gst_base_video_codec_new_frame (GstBaseVideoCodec * base_video_codec)
+{
+  GstVideoFrame *frame;
+
+  frame = g_malloc0 (sizeof (GstVideoFrame));
+
+  frame->system_frame_number = base_video_codec->system_frame_number;
+  base_video_codec->system_frame_number++;
+
+  return frame;
+}
+
+void
+gst_base_video_codec_free_frame (GstVideoFrame * frame)
+{
+  if (frame->sink_buffer) {
+    gst_buffer_unref (frame->sink_buffer);
+  }
+#if 0
+  if (frame->src_buffer) {
+    gst_buffer_unref (frame->src_buffer);
+  }
+#endif
+
+  g_free (frame);
+}
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideocodec.h schroedinger-1.0.8/gst-libs/gst/video/gstbasevideocodec.h
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideocodec.h	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideocodec.h	2009-09-11 17:35:39.000000000 +0200
@@ -0,0 +1,150 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_CODEC_H_
+#define _GST_BASE_VIDEO_CODEC_H_
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "GstBaseVideoCodec is unstable API and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/gst.h>
+#include <gst/video/gstbasevideoutils.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_BASE_VIDEO_CODEC \
+  (gst_base_video_codec_get_type())
+#define GST_BASE_VIDEO_CODEC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_VIDEO_CODEC,GstBaseVideoCodec))
+#define GST_BASE_VIDEO_CODEC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_VIDEO_CODEC,GstBaseVideoCodecClass))
+#define GST_BASE_VIDEO_CODEC_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_BASE_VIDEO_CODEC,GstBaseVideoCodecClass))
+#define GST_IS_BASE_VIDEO_CODEC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_VIDEO_CODEC))
+#define GST_IS_BASE_VIDEO_CODEC_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_VIDEO_CODEC))
+
+/**
+ * GST_BASE_VIDEO_CODEC_SINK_NAME:
+ *
+ * The name of the templates for the sink pad.
+ */
+#define GST_BASE_VIDEO_CODEC_SINK_NAME    "sink"
+/**
+ * GST_BASE_VIDEO_CODEC_SRC_NAME:
+ *
+ * The name of the templates for the source pad.
+ */
+#define GST_BASE_VIDEO_CODEC_SRC_NAME     "src"
+
+/**
+ * GST_BASE_VIDEO_CODEC_SRC_PAD:
+ * @obj: base video codec instance
+ *
+ * Gives the pointer to the source #GstPad object of the element.
+ */
+#define GST_BASE_VIDEO_CODEC_SRC_PAD(obj)         (((GstBaseVideoCodec *) (obj))->srcpad)
+
+/**
+ * GST_BASE_VIDEO_CODEC_SINK_PAD:
+ * @obj: base video codec instance
+ *
+ * Gives the pointer to the sink #GstPad object of the element.
+ */
+#define GST_BASE_VIDEO_CODEC_SINK_PAD(obj)        (((GstBaseVideoCodec *) (obj))->sinkpad)
+
+/**
+ * GST_BASE_VIDEO_CODEC_FLOW_NEED_DATA:
+ *
+ */
+#define GST_BASE_VIDEO_CODEC_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
+
+typedef struct _GstBaseVideoCodec GstBaseVideoCodec;
+typedef struct _GstBaseVideoCodecClass GstBaseVideoCodecClass;
+
+struct _GstBaseVideoCodec
+{
+  GstElement element;
+
+  /*< private >*/
+  GstPad *sinkpad;
+  GstPad *srcpad;
+  GstAdapter *input_adapter;
+  GstAdapter *output_adapter;
+
+#if 0
+  /* FIXME need to move from subclasses */
+  GstVideoState state;
+#endif
+  
+  //int reorder_depth;
+
+  //gboolean have_sync;
+  //gboolean discont;
+  //gboolean started;
+
+  //GstVideoFrame *current_frame;
+  //int distance_from_sync;
+
+  //gboolean sink_clipping;
+
+  //guint64 presentation_frame_number;
+  guint64 system_frame_number;
+
+  //GstCaps *caps;
+  //gboolean set_output_caps;
+
+  //GstClockTime buffer_timestamp;
+
+  GstClockTime timestamp_offset;
+};
+
+struct _GstBaseVideoCodecClass
+{
+  GstElementClass element_class;
+
+  gboolean (*start) (GstBaseVideoCodec *codec);
+  gboolean (*stop) (GstBaseVideoCodec *codec);
+  gboolean (*reset) (GstBaseVideoCodec *codec);
+  GstFlowReturn (*parse_data) (GstBaseVideoCodec *codec, gboolean at_eos);
+  int (*scan_for_sync) (GstAdapter *adapter, gboolean at_eos,
+      int offset, int n);
+  GstFlowReturn (*shape_output) (GstBaseVideoCodec *codec, GstVideoFrame *frame);
+  GstCaps *(*get_caps) (GstBaseVideoCodec *codec);
+
+};
+
+GType gst_base_video_codec_get_type (void);
+
+#if 0
+guint64 gst_base_video_codec_get_timestamp (GstBaseVideoCodec *codec,
+    int picture_number);
+#endif
+
+GstVideoFrame * gst_base_video_codec_new_frame (GstBaseVideoCodec *base_video_codec);
+void gst_base_video_codec_free_frame (GstVideoFrame *frame);
+
+
+G_END_DECLS
+
+#endif
+
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideodecoder.c schroedinger-1.0.8/gst-libs/gst/video/gstbasevideodecoder.c
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideodecoder.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideodecoder.c	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,1223 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideodecoder.h"
+
+#include <string.h>
+
+GST_DEBUG_CATEGORY_EXTERN (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+static void gst_base_video_decoder_finalize (GObject * object);
+
+static gboolean gst_base_video_decoder_sink_activate_push (GstPad * pad,
+    gboolean active);
+static gboolean gst_base_video_decoder_sink_setcaps (GstPad * pad,
+    GstCaps * caps);
+static gboolean gst_base_video_decoder_sink_event (GstPad * pad,
+    GstEvent * event);
+static gboolean gst_base_video_decoder_src_event (GstPad * pad,
+    GstEvent * event);
+static GstFlowReturn gst_base_video_decoder_chain (GstPad * pad,
+    GstBuffer * buf);
+static gboolean gst_base_video_decoder_sink_query (GstPad * pad,
+    GstQuery * query);
+static GstStateChangeReturn gst_base_video_decoder_change_state (GstElement *
+    element, GstStateChange transition);
+static const GstQueryType *gst_base_video_decoder_get_query_types (GstPad *
+    pad);
+static gboolean gst_base_video_decoder_src_query (GstPad * pad,
+    GstQuery * query);
+static gboolean gst_base_video_decoder_src_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value, GstFormat * dest_format,
+    gint64 * dest_value);
+static void gst_base_video_decoder_reset (GstBaseVideoDecoder *
+    base_video_decoder);
+
+static guint64
+gst_base_video_decoder_get_timestamp (GstBaseVideoDecoder * base_video_decoder,
+    int picture_number);
+static guint64
+gst_base_video_decoder_get_field_timestamp (GstBaseVideoDecoder *
+    base_video_decoder, int field_offset);
+static GstVideoFrame *gst_base_video_decoder_new_frame (GstBaseVideoDecoder *
+    base_video_decoder);
+static void gst_base_video_decoder_free_frame (GstVideoFrame * frame);
+
+GST_BOILERPLATE (GstBaseVideoDecoder, gst_base_video_decoder,
+    GstBaseVideoCodec, GST_TYPE_BASE_VIDEO_CODEC);
+
+static void
+gst_base_video_decoder_base_init (gpointer g_class)
+{
+
+}
+
+static void
+gst_base_video_decoder_class_init (GstBaseVideoDecoderClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->finalize = gst_base_video_decoder_finalize;
+
+  gstelement_class->change_state = gst_base_video_decoder_change_state;
+
+  parent_class = g_type_class_peek_parent (klass);
+}
+
+static void
+gst_base_video_decoder_init (GstBaseVideoDecoder * base_video_decoder,
+    GstBaseVideoDecoderClass * klass)
+{
+  GstPad *pad;
+
+  GST_DEBUG ("gst_base_video_decoder_init");
+
+  pad = GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_decoder);
+
+  gst_pad_set_activatepush_function (pad,
+      gst_base_video_decoder_sink_activate_push);
+  gst_pad_set_chain_function (pad, gst_base_video_decoder_chain);
+  gst_pad_set_event_function (pad, gst_base_video_decoder_sink_event);
+  gst_pad_set_setcaps_function (pad, gst_base_video_decoder_sink_setcaps);
+  gst_pad_set_query_function (pad, gst_base_video_decoder_sink_query);
+
+  pad = GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder);
+
+  gst_pad_set_event_function (pad, gst_base_video_decoder_src_event);
+  gst_pad_set_query_type_function (pad, gst_base_video_decoder_get_query_types);
+  gst_pad_set_query_function (pad, gst_base_video_decoder_src_query);
+
+  base_video_decoder->input_adapter = gst_adapter_new ();
+  base_video_decoder->output_adapter = gst_adapter_new ();
+
+  gst_segment_init (&base_video_decoder->state.segment, GST_FORMAT_TIME);
+  gst_base_video_decoder_reset (base_video_decoder);
+
+  base_video_decoder->current_frame =
+      gst_base_video_decoder_new_frame (base_video_decoder);
+
+  base_video_decoder->sink_clipping = TRUE;
+}
+
+static gboolean
+gst_base_video_decoder_sink_activate (GstBaseVideoDecoder * decoder,
+    gboolean active)
+{
+  GstBaseVideoDecoderClass *klass;
+  gboolean result = FALSE;
+
+  GST_DEBUG_OBJECT (decoder, "activate");
+
+  klass = GST_BASE_VIDEO_DECODER_GET_CLASS (decoder);
+
+  if (active) {
+    if (klass->start)
+      result = klass->start (decoder);
+  } else {
+    /* We must make sure streaming has finished before resetting things
+     * and calling the ::stop vfunc */
+    GST_PAD_STREAM_LOCK (GST_BASE_VIDEO_CODEC_SINK_PAD (decoder));
+    GST_PAD_STREAM_UNLOCK (GST_BASE_VIDEO_CODEC_SINK_PAD (decoder));
+
+    if (klass->stop)
+      result = klass->stop (decoder);
+  }
+
+  GST_DEBUG_OBJECT (decoder, "activate: %d", result);
+
+  return result;
+}
+
+static gboolean
+gst_base_video_decoder_sink_activate_push (GstPad * pad, gboolean active)
+{
+  gboolean result = TRUE;
+  GstBaseVideoDecoder *base_video_decoder;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  result = gst_base_video_decoder_sink_activate (base_video_decoder, active);
+
+  gst_object_unref (base_video_decoder);
+
+  return result;
+}
+
+static gboolean
+gst_base_video_decoder_sink_setcaps (GstPad * pad, GstCaps * caps)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstStructure *structure;
+  const GValue *codec_data;
+  gboolean res = TRUE;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  GST_DEBUG ("setcaps %" GST_PTR_FORMAT, caps);
+
+  if (base_video_decoder->codec_data) {
+    gst_buffer_unref (base_video_decoder->codec_data);
+    base_video_decoder->codec_data = NULL;
+  }
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  codec_data = gst_structure_get_value (structure, "codec_data");
+  if (codec_data && G_VALUE_TYPE (codec_data) == GST_TYPE_BUFFER) {
+    base_video_decoder->codec_data = gst_value_get_buffer (codec_data);
+  }
+
+  if (base_video_decoder_class->set_sink_caps)
+    res = base_video_decoder_class->set_sink_caps (base_video_decoder, caps);
+
+  g_object_unref (base_video_decoder);
+
+  return res;
+}
+
+static void
+gst_base_video_decoder_finalize (GObject * object)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+
+  g_return_if_fail (GST_IS_BASE_VIDEO_DECODER (object));
+  base_video_decoder = GST_BASE_VIDEO_DECODER (object);
+  base_video_decoder_class = GST_BASE_VIDEO_DECODER_GET_CLASS (object);
+
+  gst_base_video_decoder_reset (base_video_decoder);
+
+  GST_DEBUG_OBJECT (object, "finalize");
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_base_video_decoder_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  gboolean ret = FALSE;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_EOS:
+    {
+      GstVideoFrame *frame;
+
+      frame = g_malloc0 (sizeof (GstVideoFrame));
+      frame->presentation_frame_number =
+          base_video_decoder->presentation_frame_number;
+      frame->presentation_duration = 0;
+      base_video_decoder->presentation_frame_number++;
+
+      base_video_decoder->frames =
+          g_list_append (base_video_decoder->frames, frame);
+      if (base_video_decoder_class->finish) {
+        base_video_decoder_class->finish (base_video_decoder, frame);
+      }
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+          event);
+    }
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      gboolean update;
+      double rate;
+      double applied_rate;
+      GstFormat format;
+      gint64 start;
+      gint64 stop;
+      gint64 position;
+
+      gst_event_parse_new_segment_full (event, &update, &rate,
+          &applied_rate, &format, &start, &stop, &position);
+
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      gst_segment_set_newsegment_full (&base_video_decoder->state.segment,
+          update, rate, applied_rate, format, start, stop, position);
+      GST_DEBUG ("new segment %" GST_SEGMENT_FORMAT,
+          &base_video_decoder->state.segment);
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+          event);
+    }
+      break;
+    default:
+      /* FIXME this changes the order of events */
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+          event);
+      break;
+  }
+
+done:
+  gst_object_unref (base_video_decoder);
+  return ret;
+
+newseg_wrong_format:
+  {
+    GST_DEBUG_OBJECT (base_video_decoder, "received non TIME newsegment");
+    gst_event_unref (event);
+    goto done;
+  }
+}
+
+static gboolean
+gst_base_video_decoder_src_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  gboolean res = FALSE;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:
+    {
+      GstFormat format, tformat;
+      gdouble rate;
+      GstEvent *real_seek;
+      GstSeekFlags flags;
+      GstSeekType cur_type, stop_type;
+      gint64 cur, stop;
+      gint64 tcur, tstop;
+
+      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type,
+          &cur, &stop_type, &stop);
+      gst_event_unref (event);
+
+      tformat = GST_FORMAT_TIME;
+      res =
+          gst_base_video_decoder_src_convert (pad, format, cur, &tformat,
+          &tcur);
+      if (!res)
+        goto convert_error;
+      res =
+          gst_base_video_decoder_src_convert (pad, format, stop, &tformat,
+          &tstop);
+      if (!res)
+        goto convert_error;
+
+      real_seek = gst_event_new_seek (rate, GST_FORMAT_TIME,
+          flags, cur_type, tcur, stop_type, tstop);
+
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD
+          (base_video_decoder), real_seek);
+
+      break;
+    }
+    case GST_EVENT_QOS:
+    {
+      gdouble proportion;
+      GstClockTimeDiff diff;
+      GstClockTime timestamp;
+
+      gst_event_parse_qos (event, &proportion, &diff, &timestamp);
+
+      GST_OBJECT_LOCK (base_video_decoder);
+      base_video_decoder->proportion = proportion;
+      base_video_decoder->earliest_time = timestamp + diff;
+      GST_OBJECT_UNLOCK (base_video_decoder);
+
+      GST_DEBUG_OBJECT (base_video_decoder,
+          "got QoS %" GST_TIME_FORMAT ", %" G_GINT64_FORMAT ", %g",
+          GST_TIME_ARGS (timestamp), diff, proportion);
+
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD
+          (base_video_decoder), event);
+      break;
+    }
+    default:
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD
+          (base_video_decoder), event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_decoder);
+  return res;
+
+convert_error:
+  GST_DEBUG_OBJECT (base_video_decoder, "could not convert format");
+  goto done;
+}
+
+
+#if 0
+static gboolean
+gst_base_video_decoder_sink_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstBaseVideoDecoder *enc;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a decoding state */
+
+  switch (src_format) {
+    case GST_FORMAT_BYTES:
+      switch (*dest_format) {
+#if 0
+        case GST_FORMAT_DEFAULT:
+          *dest_value = gst_util_uint64_scale_int (src_value, 1,
+              enc->bytes_per_picture);
+          break;
+#endif
+        case GST_FORMAT_TIME:
+          /* seems like a rather silly conversion, implement me if you like */
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (src_value,
+              GST_SECOND * enc->fps_d, enc->fps_n);
+          break;
+#if 0
+        case GST_FORMAT_BYTES:
+          *dest_value = gst_util_uint64_scale_int (src_value,
+              enc->bytes_per_picture, 1);
+          break;
+#endif
+        default:
+          res = FALSE;
+      }
+      break;
+    default:
+      res = FALSE;
+      break;
+  }
+}
+#endif
+
+static gboolean
+gst_base_video_decoder_src_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstBaseVideoDecoder *enc;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a encoding state */
+
+  GST_DEBUG ("src convert");
+  switch (src_format) {
+#if 0
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+              enc->fps_d * GST_SECOND, enc->fps_n);
+          break;
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_TIME:
+      switch (*dest_format) {
+        case GST_FORMAT_DEFAULT:
+        {
+          *dest_value = gst_util_uint64_scale (src_value,
+              enc->fps_n, enc->fps_d * GST_SECOND);
+          break;
+        }
+        default:
+          res = FALSE;
+          break;
+      }
+      break;
+#endif
+    default:
+      res = FALSE;
+      break;
+  }
+
+  gst_object_unref (enc);
+
+  return res;
+}
+
+static const GstQueryType *
+gst_base_video_decoder_get_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_CONVERT,
+    0
+  };
+
+  return query_types;
+}
+
+static gboolean
+gst_base_video_decoder_src_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoDecoder *enc;
+  gboolean res;
+
+  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  switch GST_QUERY_TYPE
+    (query) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res =
+          gst_base_video_decoder_src_convert (pad, src_fmt, src_val, &dest_fmt,
+          &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+    }
+  gst_object_unref (enc);
+  return res;
+
+error:
+  GST_DEBUG_OBJECT (enc, "query failed");
+  gst_object_unref (enc);
+  return res;
+}
+
+static gboolean
+gst_base_video_decoder_sink_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  gboolean res = FALSE;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  GST_DEBUG_OBJECT (base_video_decoder, "sink query fps=%d/%d",
+      base_video_decoder->state.fps_n, base_video_decoder->state.fps_d);
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_rawvideo_convert (&base_video_decoder->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_video_decoder);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_video_decoder, "query failed");
+  goto done;
+}
+
+
+#if 0
+static gboolean
+gst_pad_is_negotiated (GstPad * pad)
+{
+  GstCaps *caps;
+
+  g_return_val_if_fail (pad != NULL, FALSE);
+
+  caps = gst_pad_get_negotiated_caps (pad);
+  if (caps) {
+    gst_caps_unref (caps);
+    return TRUE;
+  }
+
+  return FALSE;
+}
+#endif
+
+static void
+gst_base_video_decoder_reset (GstBaseVideoDecoder * base_video_decoder)
+{
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GList *g;
+
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  GST_DEBUG ("reset");
+
+  base_video_decoder->started = FALSE;
+
+  base_video_decoder->discont = TRUE;
+  base_video_decoder->have_sync = FALSE;
+
+  base_video_decoder->timestamp_offset = GST_CLOCK_TIME_NONE;
+  base_video_decoder->system_frame_number = 0;
+  base_video_decoder->presentation_frame_number = 0;
+  base_video_decoder->last_sink_timestamp = GST_CLOCK_TIME_NONE;
+  base_video_decoder->last_sink_offset_end = GST_CLOCK_TIME_NONE;
+  base_video_decoder->base_picture_number = 0;
+  base_video_decoder->last_timestamp = GST_CLOCK_TIME_NONE;
+
+  base_video_decoder->offset = 0;
+
+  if (base_video_decoder->caps) {
+    gst_caps_unref (base_video_decoder->caps);
+    base_video_decoder->caps = NULL;
+  }
+
+  if (base_video_decoder->current_frame) {
+    gst_base_video_decoder_free_frame (base_video_decoder->current_frame);
+    base_video_decoder->current_frame = NULL;
+  }
+
+  base_video_decoder->have_src_caps = FALSE;
+
+  for (g = g_list_first (base_video_decoder->frames); g; g = g_list_next (g)) {
+    GstVideoFrame *frame = g->data;
+    gst_base_video_decoder_free_frame (frame);
+  }
+  g_list_free (base_video_decoder->frames);
+  base_video_decoder->frames = NULL;
+
+  if (base_video_decoder_class->reset) {
+    base_video_decoder_class->reset (base_video_decoder);
+  }
+}
+
+static GstBuffer *
+gst_adapter_get_buffer (GstAdapter * adapter)
+{
+  return gst_buffer_ref (GST_BUFFER (adapter->buflist->data));
+
+}
+
+static GstFlowReturn
+gst_base_video_decoder_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *klass;
+  GstBuffer *buffer;
+  GstFlowReturn ret;
+
+  GST_DEBUG ("chain %" G_GINT64_FORMAT, GST_BUFFER_TIMESTAMP (buf));
+
+#if 0
+  /* requiring the pad to be negotiated makes it impossible to use
+   * oggdemux or filesrc ! decoder */
+  if (!gst_pad_is_negotiated (pad)) {
+    GST_DEBUG ("not negotiated");
+    return GST_FLOW_NOT_NEGOTIATED;
+  }
+#endif
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+  klass = GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  GST_DEBUG_OBJECT (base_video_decoder, "chain");
+
+  if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))) {
+    GST_DEBUG_OBJECT (base_video_decoder, "received DISCONT buffer");
+    if (base_video_decoder->started) {
+      gst_base_video_decoder_reset (base_video_decoder);
+    }
+  }
+
+  if (!base_video_decoder->started) {
+    klass->start (base_video_decoder);
+    base_video_decoder->started = TRUE;
+  }
+
+  if (GST_BUFFER_TIMESTAMP (buf) != GST_CLOCK_TIME_NONE) {
+    GST_DEBUG ("timestamp %" G_GINT64_FORMAT " offset %" G_GINT64_FORMAT,
+        GST_BUFFER_TIMESTAMP (buf), base_video_decoder->offset);
+    base_video_decoder->last_sink_timestamp = GST_BUFFER_TIMESTAMP (buf);
+  }
+  if (GST_BUFFER_OFFSET_END (buf) != -1) {
+    GST_DEBUG ("gp %" G_GINT64_FORMAT, GST_BUFFER_OFFSET_END (buf));
+    base_video_decoder->last_sink_offset_end = GST_BUFFER_OFFSET_END (buf);
+  }
+  base_video_decoder->offset += GST_BUFFER_SIZE (buf);
+
+#if 0
+  if (base_video_decoder->timestamp_offset == GST_CLOCK_TIME_NONE &&
+      GST_BUFFER_TIMESTAMP (buf) != GST_CLOCK_TIME_NONE) {
+    GST_DEBUG ("got new offset %lld", GST_BUFFER_TIMESTAMP (buf));
+    base_video_decoder->timestamp_offset = GST_BUFFER_TIMESTAMP (buf);
+  }
+#endif
+
+  if (base_video_decoder->current_frame == NULL) {
+    base_video_decoder->current_frame =
+        gst_base_video_decoder_new_frame (base_video_decoder);
+  }
+
+  gst_adapter_push (base_video_decoder->input_adapter, buf);
+
+  if (!base_video_decoder->have_sync) {
+    int n, m;
+
+    GST_DEBUG ("no sync, scanning");
+
+    n = gst_adapter_available (base_video_decoder->input_adapter);
+    m = klass->scan_for_sync (base_video_decoder, FALSE, 0, n);
+
+    if (m < 0) {
+      g_warning ("subclass returned negative scan %d", m);
+    }
+
+    if (m >= n) {
+      g_warning ("subclass scanned past end %d >= %d", m, n);
+    }
+
+    gst_adapter_flush (base_video_decoder->input_adapter, m);
+
+    if (m < n) {
+      GST_DEBUG ("found possible sync after %d bytes (of %d)", m, n);
+
+      /* this is only "maybe" sync */
+      base_video_decoder->have_sync = TRUE;
+    }
+
+    if (!base_video_decoder->have_sync) {
+      gst_object_unref (base_video_decoder);
+      return GST_FLOW_OK;
+    }
+  }
+
+  /* FIXME: use gst_adapter_prev_timestamp() here instead? */
+  buffer = gst_adapter_get_buffer (base_video_decoder->input_adapter);
+
+  base_video_decoder->buffer_timestamp = GST_BUFFER_TIMESTAMP (buffer);
+  gst_buffer_unref (buffer);
+
+  do {
+    ret = klass->parse_data (base_video_decoder, FALSE);
+  } while (ret == GST_FLOW_OK);
+
+  if (ret == GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA) {
+    gst_object_unref (base_video_decoder);
+    return GST_FLOW_OK;
+  }
+
+  gst_object_unref (base_video_decoder);
+  return ret;
+}
+
+static GstStateChangeReturn
+gst_base_video_decoder_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstStateChangeReturn ret;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (element);
+  base_video_decoder_class = GST_BASE_VIDEO_DECODER_GET_CLASS (element);
+
+  switch (transition) {
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static void
+gst_base_video_decoder_free_frame (GstVideoFrame * frame)
+{
+  g_return_if_fail (frame != NULL);
+
+  if (frame->sink_buffer) {
+    gst_buffer_unref (frame->sink_buffer);
+  }
+#if 0
+  if (frame->src_buffer) {
+    gst_buffer_unref (frame->src_buffer);
+  }
+#endif
+
+  g_free (frame);
+}
+
+static GstVideoFrame *
+gst_base_video_decoder_new_frame (GstBaseVideoDecoder * base_video_decoder)
+{
+  GstVideoFrame *frame;
+
+  frame = g_malloc0 (sizeof (GstVideoFrame));
+
+  frame->system_frame_number = base_video_decoder->system_frame_number;
+  base_video_decoder->system_frame_number++;
+
+  frame->decode_frame_number = frame->system_frame_number -
+      base_video_decoder->reorder_depth;
+
+  frame->decode_timestamp = -1;
+  frame->presentation_timestamp = -1;
+  frame->presentation_duration = -1;
+  frame->n_fields = 2;
+
+  return frame;
+}
+
+GstFlowReturn
+gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
+    GstVideoFrame * frame)
+{
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstBuffer *src_buffer;
+
+  GST_DEBUG ("finish frame");
+
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  GST_DEBUG ("finish frame sync=%d pts=%" G_GINT64_FORMAT, frame->is_sync_point,
+      frame->presentation_timestamp);
+
+  if (frame->is_sync_point) {
+    if (GST_CLOCK_TIME_IS_VALID (frame->presentation_timestamp)) {
+      if (frame->presentation_timestamp != base_video_decoder->timestamp_offset) {
+        GST_DEBUG ("sync timestamp %" G_GINT64_FORMAT " diff %" G_GINT64_FORMAT,
+            frame->presentation_timestamp,
+            frame->presentation_timestamp -
+            base_video_decoder->state.segment.start);
+        base_video_decoder->timestamp_offset = frame->presentation_timestamp;
+        base_video_decoder->field_index = 0;
+      } else {
+        /* This case is for one initial timestamp and no others, e.g.,
+         * filesrc ! decoder ! xvimagesink */
+        GST_WARNING ("sync timestamp didn't change, ignoring");
+        frame->presentation_timestamp = GST_CLOCK_TIME_NONE;
+      }
+    } else {
+      GST_WARNING ("sync point doesn't have timestamp");
+      if (GST_CLOCK_TIME_IS_VALID (base_video_decoder->timestamp_offset)) {
+        GST_ERROR ("No base timestamp.  Assuming frames start at 0");
+        base_video_decoder->timestamp_offset = 0;
+        base_video_decoder->field_index = 0;
+      }
+    }
+  }
+  frame->field_index = base_video_decoder->field_index;
+  base_video_decoder->field_index += frame->n_fields;
+
+  if (frame->presentation_timestamp == GST_CLOCK_TIME_NONE) {
+    frame->presentation_timestamp =
+        gst_base_video_decoder_get_field_timestamp (base_video_decoder,
+        frame->field_index);
+    frame->presentation_duration = GST_CLOCK_TIME_NONE;
+    frame->decode_timestamp =
+        gst_base_video_decoder_get_timestamp (base_video_decoder,
+        frame->decode_frame_number);
+  }
+  if (frame->presentation_duration == GST_CLOCK_TIME_NONE) {
+    frame->presentation_duration =
+        gst_base_video_decoder_get_field_timestamp (base_video_decoder,
+        frame->field_index + frame->n_fields) - frame->presentation_timestamp;
+  }
+
+  if (GST_CLOCK_TIME_IS_VALID (base_video_decoder->last_timestamp)) {
+    if (frame->presentation_timestamp < base_video_decoder->last_timestamp) {
+      GST_WARNING ("decreasing timestamp (%" G_GINT64_FORMAT " < %"
+          G_GINT64_FORMAT ")", frame->presentation_timestamp,
+          base_video_decoder->last_timestamp);
+    }
+  }
+  base_video_decoder->last_timestamp = frame->presentation_timestamp;
+
+  GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  if (base_video_decoder->state.interlaced) {
+#ifndef GST_VIDEO_BUFFER_TFF
+#define GST_VIDEO_BUFFER_TFF (GST_MINI_OBJECT_FLAG_LAST << 5)
+#endif
+#ifndef GST_VIDEO_BUFFER_RFF
+#define GST_VIDEO_BUFFER_RFF (GST_MINI_OBJECT_FLAG_LAST << 6)
+#endif
+#ifndef GST_VIDEO_BUFFER_ONEFIELD
+#define GST_VIDEO_BUFFER_ONEFIELD (GST_MINI_OBJECT_FLAG_LAST << 7)
+#endif
+    int tff = base_video_decoder->state.top_field_first;
+
+    if (frame->field_index & 1) {
+      tff ^= 1;
+    }
+    if (tff) {
+      GST_BUFFER_FLAG_SET (frame->src_buffer, GST_VIDEO_BUFFER_TFF);
+    } else {
+      GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_VIDEO_BUFFER_TFF);
+    }
+    GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_VIDEO_BUFFER_RFF);
+    GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_VIDEO_BUFFER_ONEFIELD);
+    if (frame->n_fields == 3) {
+      GST_BUFFER_FLAG_SET (frame->src_buffer, GST_VIDEO_BUFFER_RFF);
+    } else if (frame->n_fields == 1) {
+      GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_VIDEO_BUFFER_ONEFIELD);
+    }
+  }
+
+  GST_BUFFER_TIMESTAMP (frame->src_buffer) = frame->presentation_timestamp;
+  GST_BUFFER_DURATION (frame->src_buffer) = frame->presentation_duration;
+  GST_BUFFER_OFFSET (frame->src_buffer) = -1;
+  GST_BUFFER_OFFSET_END (frame->src_buffer) = -1;
+
+  GST_DEBUG ("pushing frame %" G_GINT64_FORMAT, frame->presentation_timestamp);
+
+  base_video_decoder->frames =
+      g_list_remove (base_video_decoder->frames, frame);
+
+  gst_base_video_decoder_set_src_caps (base_video_decoder);
+
+  src_buffer = frame->src_buffer;
+  frame->src_buffer = NULL;
+
+  gst_base_video_decoder_free_frame (frame);
+
+  if (base_video_decoder->sink_clipping) {
+    gint64 start = GST_BUFFER_TIMESTAMP (src_buffer);
+    gint64 stop = GST_BUFFER_TIMESTAMP (src_buffer) +
+        GST_BUFFER_DURATION (src_buffer);
+
+    if (gst_segment_clip (&base_video_decoder->state.segment, GST_FORMAT_TIME,
+            start, stop, &start, &stop)) {
+      GST_BUFFER_TIMESTAMP (src_buffer) = start;
+      GST_BUFFER_DURATION (src_buffer) = stop - start;
+    } else {
+      GST_DEBUG ("dropping buffer outside segment");
+      gst_buffer_unref (src_buffer);
+      return GST_FLOW_OK;
+    }
+  }
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+      src_buffer);
+}
+
+int
+gst_base_video_decoder_get_height (GstBaseVideoDecoder * base_video_decoder)
+{
+  return base_video_decoder->state.height;
+}
+
+int
+gst_base_video_decoder_get_width (GstBaseVideoDecoder * base_video_decoder)
+{
+  return base_video_decoder->state.width;
+}
+
+GstFlowReturn
+gst_base_video_decoder_end_of_stream (GstBaseVideoDecoder * base_video_decoder,
+    GstBuffer * buffer)
+{
+
+  if (base_video_decoder->frames) {
+    GST_DEBUG ("EOS with frames left over");
+  }
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+      buffer);
+}
+
+void
+gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder * base_video_decoder,
+    int n_bytes)
+{
+  GstBuffer *buf;
+
+  GST_DEBUG ("add to frame");
+
+#if 0
+  if (gst_adapter_available (base_video_decoder->output_adapter) == 0) {
+    GstBuffer *buffer;
+
+    buffer =
+        gst_adapter_get_orig_buffer_at_offset
+        (base_video_decoder->input_adapter, 0);
+    if (buffer) {
+      base_video_decoder->current_frame->presentation_timestamp =
+          GST_BUFFER_TIMESTAMP (buffer);
+      gst_buffer_unref (buffer);
+    }
+  }
+#endif
+
+  if (n_bytes == 0)
+    return;
+
+  buf = gst_adapter_take_buffer (base_video_decoder->input_adapter, n_bytes);
+
+  gst_adapter_push (base_video_decoder->output_adapter, buf);
+}
+
+static guint64
+gst_base_video_decoder_get_timestamp (GstBaseVideoDecoder * base_video_decoder,
+    int picture_number)
+{
+  if (base_video_decoder->state.fps_d == 0) {
+    return -1;
+  }
+  if (picture_number < base_video_decoder->base_picture_number) {
+    return base_video_decoder->timestamp_offset -
+        (gint64) gst_util_uint64_scale (base_video_decoder->base_picture_number
+        - picture_number, base_video_decoder->state.fps_d * GST_SECOND,
+        base_video_decoder->state.fps_n);
+  } else {
+    return base_video_decoder->timestamp_offset +
+        gst_util_uint64_scale (picture_number -
+        base_video_decoder->base_picture_number,
+        base_video_decoder->state.fps_d * GST_SECOND,
+        base_video_decoder->state.fps_n);
+  }
+}
+
+static guint64
+gst_base_video_decoder_get_field_timestamp (GstBaseVideoDecoder *
+    base_video_decoder, int field_offset)
+{
+  if (base_video_decoder->state.fps_d == 0) {
+    return GST_CLOCK_TIME_NONE;
+  }
+  if (field_offset < 0) {
+    GST_WARNING ("field offset < 0");
+    return GST_CLOCK_TIME_NONE;
+  }
+  return base_video_decoder->timestamp_offset +
+      gst_util_uint64_scale (field_offset,
+      base_video_decoder->state.fps_d * GST_SECOND,
+      base_video_decoder->state.fps_n * 2);
+}
+
+
+GstFlowReturn
+gst_base_video_decoder_have_frame (GstBaseVideoDecoder * base_video_decoder)
+{
+  GstVideoFrame *frame = base_video_decoder->current_frame;
+  GstBuffer *buffer;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstFlowReturn ret = GST_FLOW_OK;
+  int n_available;
+
+  GST_DEBUG ("have_frame");
+
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  n_available = gst_adapter_available (base_video_decoder->output_adapter);
+  if (n_available) {
+    buffer = gst_adapter_take_buffer (base_video_decoder->output_adapter,
+        n_available);
+  } else {
+    buffer = gst_buffer_new_and_alloc (0);
+  }
+
+  frame->distance_from_sync = base_video_decoder->distance_from_sync;
+  base_video_decoder->distance_from_sync++;
+
+#if 0
+  if (frame->presentation_timestamp == GST_CLOCK_TIME_NONE) {
+    frame->presentation_timestamp =
+        gst_base_video_decoder_get_timestamp (base_video_decoder,
+        frame->presentation_frame_number);
+    frame->presentation_duration =
+        gst_base_video_decoder_get_timestamp (base_video_decoder,
+        frame->presentation_frame_number + 1) - frame->presentation_timestamp;
+    frame->decode_timestamp =
+        gst_base_video_decoder_get_timestamp (base_video_decoder,
+        frame->decode_frame_number);
+  }
+#endif
+
+#if 0
+  GST_BUFFER_TIMESTAMP (buffer) = frame->presentation_timestamp;
+  GST_BUFFER_DURATION (buffer) = frame->presentation_duration;
+  if (frame->decode_frame_number < 0) {
+    GST_BUFFER_OFFSET (buffer) = 0;
+  } else {
+    GST_BUFFER_OFFSET (buffer) = frame->decode_timestamp;
+  }
+  GST_BUFFER_OFFSET_END (buffer) = GST_CLOCK_TIME_NONE;
+#endif
+
+  GST_DEBUG ("pts %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (frame->presentation_timestamp));
+  GST_DEBUG ("dts %" GST_TIME_FORMAT, GST_TIME_ARGS (frame->decode_timestamp));
+  GST_DEBUG ("dist %d", frame->distance_from_sync);
+
+  if (frame->is_sync_point) {
+    GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+  if (base_video_decoder->discont) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+    base_video_decoder->discont = FALSE;
+  }
+
+  frame->sink_buffer = buffer;
+
+  base_video_decoder->frames = g_list_append (base_video_decoder->frames,
+      frame);
+
+  /* do something with frame */
+  ret = base_video_decoder_class->handle_frame (base_video_decoder, frame);
+  if (!GST_FLOW_IS_SUCCESS (ret)) {
+    GST_DEBUG ("flow error!");
+  }
+
+  /* create new frame */
+  base_video_decoder->current_frame =
+      gst_base_video_decoder_new_frame (base_video_decoder);
+
+  return ret;
+}
+
+GstVideoState *
+gst_base_video_decoder_get_state (GstBaseVideoDecoder * base_video_decoder)
+{
+  return &base_video_decoder->state;
+
+}
+
+void
+gst_base_video_decoder_set_state (GstBaseVideoDecoder * base_video_decoder,
+    GstVideoState * state)
+{
+  memcpy (&base_video_decoder->state, state, sizeof (*state));
+
+}
+
+void
+gst_base_video_decoder_lost_sync (GstBaseVideoDecoder * base_video_decoder)
+{
+  g_return_if_fail (GST_IS_BASE_VIDEO_DECODER (base_video_decoder));
+
+  GST_DEBUG ("lost_sync");
+
+  if (gst_adapter_available (base_video_decoder->input_adapter) >= 1) {
+    gst_adapter_flush (base_video_decoder->input_adapter, 1);
+  }
+
+  base_video_decoder->have_sync = FALSE;
+}
+
+void
+gst_base_video_decoder_set_sync_point (GstBaseVideoDecoder * base_video_decoder)
+{
+  GST_DEBUG ("set_sync_point");
+
+  base_video_decoder->current_frame->is_sync_point = TRUE;
+  base_video_decoder->distance_from_sync = 0;
+
+  base_video_decoder->current_frame->presentation_timestamp =
+      base_video_decoder->last_sink_timestamp;
+
+
+}
+
+GstVideoFrame *
+gst_base_video_decoder_get_frame (GstBaseVideoDecoder * base_video_decoder,
+    int frame_number)
+{
+  GList *g;
+
+  for (g = g_list_first (base_video_decoder->frames); g; g = g_list_next (g)) {
+    GstVideoFrame *frame = g->data;
+
+    if (frame->system_frame_number == frame_number) {
+      return frame;
+    }
+  }
+
+  return NULL;
+}
+
+void
+gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder * base_video_decoder)
+{
+  GstCaps *caps;
+  GstVideoState *state = &base_video_decoder->state;
+
+  if (base_video_decoder->have_src_caps)
+    return;
+
+  caps = gst_video_format_new_caps (state->format,
+      state->width, state->height,
+      state->fps_n, state->fps_d, state->par_n, state->par_d);
+  gst_caps_set_simple (caps, "interlaced",
+      G_TYPE_BOOLEAN, state->interlaced, NULL);
+
+  GST_DEBUG ("setting caps %" GST_PTR_FORMAT, caps);
+
+  gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder), caps);
+
+  base_video_decoder->have_src_caps = TRUE;
+}
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideodecoder.h schroedinger-1.0.8/gst-libs/gst/video/gstbasevideodecoder.h
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideodecoder.h	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideodecoder.h	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,163 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_DECODER_H_
+#define _GST_BASE_VIDEO_DECODER_H_
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "GstBaseVideoDecoder is unstable API and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/video/gstbasevideocodec.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_BASE_VIDEO_DECODER \
+  (gst_base_video_decoder_get_type())
+#define GST_BASE_VIDEO_DECODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_VIDEO_DECODER,GstBaseVideoDecoder))
+#define GST_BASE_VIDEO_DECODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_VIDEO_DECODER,GstBaseVideoDecoderClass))
+#define GST_BASE_VIDEO_DECODER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_BASE_VIDEO_DECODER,GstBaseVideoDecoderClass))
+#define GST_IS_BASE_VIDEO_DECODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_VIDEO_DECODER))
+#define GST_IS_BASE_VIDEO_DECODER_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_VIDEO_DECODER))
+
+/**
+ * GST_BASE_VIDEO_DECODER_SINK_NAME:
+ *
+ * The name of the templates for the sink pad.
+ */
+#define GST_BASE_VIDEO_DECODER_SINK_NAME    "sink"
+/**
+ * GST_BASE_VIDEO_DECODER_SRC_NAME:
+ *
+ * The name of the templates for the source pad.
+ */
+#define GST_BASE_VIDEO_DECODER_SRC_NAME     "src"
+
+/**
+ * GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA:
+ *
+ * Custom GstFlowReturn value indicating that more data is needed.
+ */
+#define GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
+
+
+typedef struct _GstBaseVideoDecoder GstBaseVideoDecoder;
+typedef struct _GstBaseVideoDecoderClass GstBaseVideoDecoderClass;
+
+struct _GstBaseVideoDecoder
+{
+  GstBaseVideoCodec base_video_codec;
+
+  /*< private >*/
+  GstAdapter *input_adapter;
+  GstAdapter *output_adapter;
+
+  GList *frames;
+
+  gboolean have_sync;
+  gboolean discont;
+  gboolean started;
+
+  GstVideoState state;
+
+  gboolean sink_clipping;
+
+  guint64 presentation_frame_number;
+  guint64 system_frame_number;
+
+  GstCaps *caps;
+  gboolean have_src_caps;
+
+  GstVideoFrame *current_frame;
+
+  int distance_from_sync;
+  int reorder_depth;
+
+  GstClockTime buffer_timestamp;
+
+  GstClockTime timestamp_offset;
+
+  gdouble proportion;
+  GstClockTime earliest_time;
+
+  GstBuffer *codec_data;
+
+  guint64 offset;
+  GstClockTime last_timestamp;
+
+  GstClockTime last_sink_timestamp;
+  GstClockTime last_sink_offset_end;
+  guint64 base_picture_number;
+
+  int field_index;
+};
+
+struct _GstBaseVideoDecoderClass
+{
+  GstBaseVideoCodecClass base_video_codec_class;
+
+  gboolean (*set_sink_caps) (GstBaseVideoDecoder *coder, GstCaps *caps);
+  gboolean (*start) (GstBaseVideoDecoder *coder);
+  gboolean (*stop) (GstBaseVideoDecoder *coder);
+  gboolean (*reset) (GstBaseVideoDecoder *coder);
+  int (*scan_for_sync) (GstBaseVideoDecoder *decoder, gboolean at_eos,
+      int offset, int n);
+  GstFlowReturn (*parse_data) (GstBaseVideoDecoder *decoder, gboolean at_eos);
+  gboolean (*finish) (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
+  GstFlowReturn (*handle_frame) (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
+  GstFlowReturn (*shape_output) (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
+  GstCaps *(*get_caps) (GstBaseVideoDecoder *coder);
+};
+
+GType gst_base_video_decoder_get_type (void);
+
+int gst_base_video_decoder_get_width (GstBaseVideoDecoder *coder);
+int gst_base_video_decoder_get_height (GstBaseVideoDecoder *coder);
+
+guint64 gst_base_video_decoder_get_timestamp_offset (GstBaseVideoDecoder *coder);
+
+GstVideoFrame *gst_base_video_decoder_get_frame (GstBaseVideoDecoder *coder,
+    int frame_number);
+void gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder *base_video_decoder,
+    int n_bytes);
+GstFlowReturn gst_base_video_decoder_finish_frame (GstBaseVideoDecoder *base_video_decoder,
+    GstVideoFrame *frame);
+GstFlowReturn gst_base_video_decoder_end_of_stream (GstBaseVideoDecoder *base_video_decoder,
+    GstBuffer *buffer);
+GstFlowReturn
+gst_base_video_decoder_have_frame (GstBaseVideoDecoder *base_video_decoder);
+GstVideoState * gst_base_video_decoder_get_state (GstBaseVideoDecoder *base_video_decoder);
+void gst_base_video_decoder_set_state (GstBaseVideoDecoder *base_video_decoder,
+    GstVideoState *state);
+void gst_base_video_decoder_lost_sync (GstBaseVideoDecoder *base_video_decoder);
+void gst_base_video_decoder_set_sync_point (GstBaseVideoDecoder *base_video_decoder);
+
+void gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder *base_video_decoder);
+
+
+G_END_DECLS
+
+#endif
+
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoencoder.c schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoencoder.c
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoencoder.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoencoder.c	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,521 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideoencoder.h"
+#include "gstbasevideoutils.h"
+
+GST_DEBUG_CATEGORY_EXTERN (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+static void gst_base_video_encoder_finalize (GObject * object);
+
+static gboolean gst_base_video_encoder_sink_setcaps (GstPad * pad,
+    GstCaps * caps);
+static gboolean gst_base_video_encoder_sink_event (GstPad * pad,
+    GstEvent * event);
+static GstFlowReturn gst_base_video_encoder_chain (GstPad * pad,
+    GstBuffer * buf);
+static GstStateChangeReturn gst_base_video_encoder_change_state (GstElement *
+    element, GstStateChange transition);
+static const GstQueryType *gst_base_video_encoder_get_query_types (GstPad *
+    pad);
+static gboolean gst_base_video_encoder_src_query (GstPad * pad,
+    GstQuery * query);
+
+static void
+_do_init (GType object_type)
+{
+  const GInterfaceInfo preset_interface_info = {
+    NULL,                       /* interface_init */
+    NULL,                       /* interface_finalize */
+    NULL                        /* interface_data */
+  };
+
+  g_type_add_interface_static (object_type, GST_TYPE_PRESET,
+      &preset_interface_info);
+}
+
+GST_BOILERPLATE_FULL (GstBaseVideoEncoder, gst_base_video_encoder,
+    GstBaseVideoCodec, GST_TYPE_BASE_VIDEO_CODEC, _do_init);
+
+static void
+gst_base_video_encoder_base_init (gpointer g_class)
+{
+
+}
+
+static void
+gst_base_video_encoder_class_init (GstBaseVideoEncoderClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->finalize = gst_base_video_encoder_finalize;
+
+  gstelement_class->change_state = gst_base_video_encoder_change_state;
+
+  parent_class = g_type_class_peek_parent (klass);
+}
+
+static void
+gst_base_video_encoder_init (GstBaseVideoEncoder * base_video_encoder,
+    GstBaseVideoEncoderClass * klass)
+{
+  GstPad *pad;
+
+  GST_DEBUG ("gst_base_video_encoder_init");
+
+  pad = GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_encoder);
+
+  gst_pad_set_chain_function (pad, gst_base_video_encoder_chain);
+  gst_pad_set_event_function (pad, gst_base_video_encoder_sink_event);
+  gst_pad_set_setcaps_function (pad, gst_base_video_encoder_sink_setcaps);
+
+  pad = GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder);
+
+  gst_pad_set_query_type_function (pad, gst_base_video_encoder_get_query_types);
+  gst_pad_set_query_function (pad, gst_base_video_encoder_src_query);
+}
+
+static gboolean
+gst_base_video_encoder_sink_setcaps (GstPad * pad, GstCaps * caps)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+  gboolean res;
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  base_video_encoder_class =
+      GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
+
+  GST_DEBUG ("setcaps");
+
+  gst_base_video_state_from_caps (&base_video_encoder->state, caps);
+
+  res = base_video_encoder_class->set_format (base_video_encoder,
+      &base_video_encoder->state);
+
+  base_video_encoder_class->start (base_video_encoder);
+
+  g_object_unref (base_video_encoder);
+
+  return res;
+}
+
+static void
+gst_base_video_encoder_finalize (GObject * object)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+
+  g_return_if_fail (GST_IS_BASE_VIDEO_ENCODER (object));
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (object);
+  base_video_encoder_class = GST_BASE_VIDEO_ENCODER_GET_CLASS (object);
+
+  GST_DEBUG ("finalize");
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_base_video_encoder_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+  gboolean ret = FALSE;
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  base_video_encoder_class =
+      GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_EOS:
+    {
+      GstVideoFrame *frame;
+
+      frame = g_malloc0 (sizeof (GstVideoFrame));
+      frame->presentation_frame_number =
+          base_video_encoder->presentation_frame_number;
+      frame->presentation_duration = 0;
+      frame->is_eos = TRUE;
+      base_video_encoder->presentation_frame_number++;
+
+      base_video_encoder->frames =
+          g_list_append (base_video_encoder->frames, frame);
+      base_video_encoder_class->finish (base_video_encoder, frame);
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+          event);
+    }
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      gboolean update;
+      double rate;
+      double applied_rate;
+      GstFormat format;
+      gint64 start;
+      gint64 stop;
+      gint64 position;
+
+      gst_event_parse_new_segment_full (event, &update, &rate,
+          &applied_rate, &format, &start, &stop, &position);
+
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      GST_DEBUG ("new segment %" G_GINT64_FORMAT " %" G_GINT64_FORMAT, start,
+          position);
+
+      gst_segment_set_newsegment_full (&base_video_encoder->state.segment,
+          update, rate, applied_rate, format, start, stop, position);
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+          event);
+    }
+      break;
+    default:
+      /* FIXME this changes the order of events */
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+          event);
+      break;
+  }
+
+done:
+  gst_object_unref (base_video_encoder);
+  return ret;
+
+newseg_wrong_format:
+  {
+    GST_DEBUG_OBJECT (base_video_encoder, "received non TIME newsegment");
+    gst_event_unref (event);
+    goto done;
+  }
+}
+
+static const GstQueryType *
+gst_base_video_encoder_get_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_CONVERT,
+    GST_QUERY_LATENCY,
+    0
+  };
+
+  return query_types;
+}
+
+static gboolean
+gst_base_video_encoder_src_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoEncoder *enc;
+  gboolean res;
+  GstPad *peerpad;
+
+  enc = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  peerpad = gst_pad_get_peer (GST_BASE_VIDEO_CODEC_SINK_PAD (enc));
+
+  switch GST_QUERY_TYPE
+    (query) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res =
+          gst_base_video_encoded_video_convert (&enc->state, src_fmt, src_val,
+          &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    case GST_QUERY_LATENCY:
+    {
+      gboolean live;
+      GstClockTime min_latency, max_latency;
+
+      res = gst_pad_query (peerpad, query);
+      if (res) {
+        gst_query_parse_latency (query, &live, &min_latency, &max_latency);
+
+        min_latency += enc->min_latency;
+        if (max_latency != GST_CLOCK_TIME_NONE) {
+          max_latency += enc->max_latency;
+        }
+
+        gst_query_set_latency (query, live, min_latency, max_latency);
+      }
+    }
+      break;
+    default:
+      res = gst_pad_query_default (pad, query);
+    }
+  gst_object_unref (peerpad);
+  gst_object_unref (enc);
+  return res;
+
+error:
+  GST_DEBUG_OBJECT (enc, "query failed");
+  gst_object_unref (peerpad);
+  gst_object_unref (enc);
+  return res;
+}
+
+static gboolean
+gst_pad_is_negotiated (GstPad * pad)
+{
+  GstCaps *caps;
+
+  g_return_val_if_fail (pad != NULL, FALSE);
+
+  caps = gst_pad_get_negotiated_caps (pad);
+  if (caps) {
+    gst_caps_unref (caps);
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
+static GstFlowReturn
+gst_base_video_encoder_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *klass;
+  GstVideoFrame *frame;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  if (!gst_pad_is_negotiated (pad)) {
+    return GST_FLOW_NOT_NEGOTIATED;
+  }
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  klass = GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
+
+  if (base_video_encoder->sink_clipping) {
+    gint64 start = GST_BUFFER_TIMESTAMP (buf);
+    gint64 stop = start + GST_BUFFER_DURATION (buf);
+    gint64 clip_start;
+    gint64 clip_stop;
+
+    if (!gst_segment_clip (&base_video_encoder->state.segment,
+            GST_FORMAT_TIME, start, stop, &clip_start, &clip_stop)) {
+      GST_DEBUG ("clipping to segment dropped frame");
+      goto done;
+    }
+  }
+
+  frame = g_malloc0 (sizeof (GstVideoFrame));
+  frame->sink_buffer = buf;
+  frame->presentation_timestamp = GST_BUFFER_TIMESTAMP (buf);
+  frame->presentation_duration = GST_BUFFER_DURATION (buf);
+  frame->presentation_frame_number =
+      base_video_encoder->presentation_frame_number;
+  base_video_encoder->presentation_frame_number++;
+
+  base_video_encoder->frames =
+      g_list_append (base_video_encoder->frames, frame);
+
+  ret = klass->handle_frame (base_video_encoder, frame);
+
+done:
+  g_object_unref (base_video_encoder);
+
+  return ret;
+}
+
+static GstStateChangeReturn
+gst_base_video_encoder_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+  GstStateChangeReturn ret;
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (element);
+  base_video_encoder_class = GST_BASE_VIDEO_ENCODER_GET_CLASS (element);
+
+  switch (transition) {
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      if (base_video_encoder_class->stop) {
+        base_video_encoder_class->stop (base_video_encoder);
+      }
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+GstFlowReturn
+gst_base_video_encoder_finish_frame (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstFlowReturn ret;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+
+  base_video_encoder_class =
+      GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
+
+  frame->system_frame_number = base_video_encoder->system_frame_number;
+  base_video_encoder->system_frame_number++;
+
+  if (frame->is_sync_point) {
+    base_video_encoder->distance_from_sync = 0;
+    GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (frame->src_buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  frame->distance_from_sync = base_video_encoder->distance_from_sync;
+  base_video_encoder->distance_from_sync++;
+
+  frame->decode_frame_number = frame->system_frame_number - 1;
+  if (frame->decode_frame_number < 0) {
+    frame->decode_timestamp = 0;
+  } else {
+    frame->decode_timestamp = gst_util_uint64_scale (frame->decode_frame_number,
+        GST_SECOND * base_video_encoder->state.fps_d,
+        base_video_encoder->state.fps_n);
+  }
+
+  GST_BUFFER_TIMESTAMP (frame->src_buffer) = frame->presentation_timestamp;
+  GST_BUFFER_DURATION (frame->src_buffer) = frame->presentation_duration;
+  GST_BUFFER_OFFSET (frame->src_buffer) = frame->decode_timestamp;
+
+  base_video_encoder->frames =
+      g_list_remove (base_video_encoder->frames, frame);
+
+  if (!base_video_encoder->set_output_caps) {
+    GstCaps *caps;
+
+    if (base_video_encoder_class->get_caps) {
+      caps = base_video_encoder_class->get_caps (base_video_encoder);
+    } else {
+      caps = gst_caps_new_simple ("video/unknown", NULL);
+    }
+    base_video_encoder->caps = gst_caps_ref (caps);
+    gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), caps);
+    base_video_encoder->set_output_caps = TRUE;
+  }
+
+  if (base_video_encoder_class->shape_output) {
+    ret = base_video_encoder_class->shape_output (base_video_encoder, frame);
+  } else {
+    ret =
+        gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+        frame->src_buffer);
+  }
+
+  gst_base_video_codec_free_frame (frame);
+
+  return ret;
+}
+
+int
+gst_base_video_encoder_get_height (GstBaseVideoEncoder * base_video_encoder)
+{
+  return base_video_encoder->state.height;
+}
+
+int
+gst_base_video_encoder_get_width (GstBaseVideoEncoder * base_video_encoder)
+{
+  return base_video_encoder->state.width;
+}
+
+const GstVideoState *
+gst_base_video_encoder_get_state (GstBaseVideoEncoder * base_video_encoder)
+{
+  return &base_video_encoder->state;
+}
+
+GstFlowReturn
+gst_base_video_encoder_end_of_stream (GstBaseVideoEncoder * base_video_encoder,
+    GstBuffer * buffer)
+{
+
+  if (base_video_encoder->frames) {
+    GST_WARNING ("EOS with frames left over");
+  }
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+      buffer);
+}
+
+void
+gst_base_video_encoder_set_latency (GstBaseVideoEncoder * base_video_encoder,
+    GstClockTime min_latency, GstClockTime max_latency)
+{
+  g_return_if_fail (min_latency >= 0);
+  g_return_if_fail (max_latency >= min_latency);
+
+  base_video_encoder->min_latency = min_latency;
+  base_video_encoder->max_latency = max_latency;
+}
+
+void
+gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *
+    base_video_encoder, int n_fields)
+{
+  gint64 latency;
+
+  latency = gst_util_uint64_scale (n_fields,
+      base_video_encoder->state.fps_d * GST_SECOND,
+      2 * base_video_encoder->state.fps_n);
+
+  gst_base_video_encoder_set_latency (base_video_encoder, latency, latency);
+
+}
+
+GstVideoFrame *
+gst_base_video_encoder_get_frame (GstBaseVideoEncoder * coder, int frame_number)
+{
+  GList *g;
+
+  for (g = coder->frames; g; g = g_list_next (g)) {
+    GstVideoFrame *frame = g->data;
+
+    if (frame->system_frame_number == frame_number) {
+      return frame;
+    }
+  }
+
+  return NULL;
+}
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoencoder.h schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoencoder.h
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoencoder.h	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoencoder.h	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,123 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_ENCODER_H_
+#define _GST_BASE_VIDEO_ENCODER_H_
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "GstBaseVideoEncoder is unstable API and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/video/gstbasevideocodec.h>
+#include <gst/video/gstbasevideoutils.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_BASE_VIDEO_ENCODER \
+  (gst_base_video_encoder_get_type())
+#define GST_BASE_VIDEO_ENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_VIDEO_ENCODER,GstBaseVideoEncoder))
+#define GST_BASE_VIDEO_ENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_VIDEO_ENCODER,GstBaseVideoEncoderClass))
+#define GST_BASE_VIDEO_ENCODER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_BASE_VIDEO_ENCODER,GstBaseVideoEncoderClass))
+#define GST_IS_BASE_VIDEO_ENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_VIDEO_ENCODER))
+#define GST_IS_BASE_VIDEO_ENCODER_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_VIDEO_ENCODER))
+
+/**
+ * GST_BASE_VIDEO_ENCODER_SINK_NAME:
+ *
+ * The name of the templates for the sink pad.
+ */
+#define GST_BASE_VIDEO_ENCODER_SINK_NAME    "sink"
+/**
+ * GST_BASE_VIDEO_ENCODER_SRC_NAME:
+ *
+ * The name of the templates for the source pad.
+ */
+#define GST_BASE_VIDEO_ENCODER_SRC_NAME     "src"
+
+
+typedef struct _GstBaseVideoEncoder GstBaseVideoEncoder;
+typedef struct _GstBaseVideoEncoderClass GstBaseVideoEncoderClass;
+
+struct _GstBaseVideoEncoder
+{
+  GstBaseVideoCodec base_video_codec;
+
+  /*< private >*/
+  GList *frames;
+
+  GstVideoState state;
+
+  gboolean sink_clipping;
+
+  guint64 presentation_frame_number;
+  guint64 system_frame_number;
+  int distance_from_sync;
+
+  GstCaps *caps;
+  gboolean set_output_caps;
+
+  gint64 min_latency;
+  gint64 max_latency;
+};
+
+struct _GstBaseVideoEncoderClass
+{
+  GstBaseVideoCodecClass base_video_codec_class;
+
+  gboolean (*set_format) (GstBaseVideoEncoder *coder, GstVideoState *state);
+  gboolean (*start) (GstBaseVideoEncoder *coder);
+  gboolean (*stop) (GstBaseVideoEncoder *coder);
+  gboolean (*finish) (GstBaseVideoEncoder *coder, GstVideoFrame *frame);
+  GstFlowReturn (*handle_frame) (GstBaseVideoEncoder *coder, GstVideoFrame *frame);
+  GstFlowReturn (*shape_output) (GstBaseVideoEncoder *coder, GstVideoFrame *frame);
+  GstCaps *(*get_caps) (GstBaseVideoEncoder *coder);
+
+};
+
+GType gst_base_video_encoder_get_type (void);
+
+int gst_base_video_encoder_get_width (GstBaseVideoEncoder *coder);
+int gst_base_video_encoder_get_height (GstBaseVideoEncoder *coder);
+const GstVideoState *gst_base_video_encoder_get_state (GstBaseVideoEncoder *coder);
+
+guint64 gst_base_video_encoder_get_timestamp_offset (GstBaseVideoEncoder *coder);
+
+GstVideoFrame *gst_base_video_encoder_get_frame (GstBaseVideoEncoder *coder,
+    int frame_number);
+GstFlowReturn gst_base_video_encoder_finish_frame (GstBaseVideoEncoder *base_video_encoder,
+    GstVideoFrame *frame);
+GstFlowReturn gst_base_video_encoder_end_of_stream (GstBaseVideoEncoder *base_video_encoder,
+    GstBuffer *buffer);
+
+void gst_base_video_encoder_set_latency (GstBaseVideoEncoder *base_video_encoder,
+    GstClockTime min_latency, GstClockTime max_latency);
+void gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *base_video_encoder,
+    int n_fields);
+
+
+G_END_DECLS
+
+#endif
+
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoparse.c schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoparse.c
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoparse.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoparse.c	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,871 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideoparse.h"
+
+#include <string.h>
+#include <math.h>
+
+GST_DEBUG_CATEGORY_EXTERN (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+
+
+/* GstBaseVideoParse signals and args */
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_base_video_parse_finalize (GObject * object);
+
+static const GstQueryType *gst_base_video_parse_get_query_types (GstPad * pad);
+static gboolean gst_base_video_parse_src_query (GstPad * pad, GstQuery * query);
+static gboolean gst_base_video_parse_sink_query (GstPad * pad,
+    GstQuery * query);
+static gboolean gst_base_video_parse_src_event (GstPad * pad, GstEvent * event);
+static gboolean gst_base_video_parse_sink_event (GstPad * pad,
+    GstEvent * event);
+static GstStateChangeReturn gst_base_video_parse_change_state (GstElement *
+    element, GstStateChange transition);
+static GstFlowReturn gst_base_video_parse_push_all (GstBaseVideoParse *
+    base_video_parse, gboolean at_eos);
+static GstFlowReturn gst_base_video_parse_chain (GstPad * pad, GstBuffer * buf);
+static void gst_base_video_parse_free_frame (GstVideoFrame * frame);
+static GstVideoFrame *gst_base_video_parse_new_frame (GstBaseVideoParse *
+    base_video_parse);
+
+
+GST_BOILERPLATE (GstBaseVideoParse, gst_base_video_parse,
+    GstBaseVideoCodec, GST_TYPE_BASE_VIDEO_CODEC);
+
+static void
+gst_base_video_parse_base_init (gpointer g_class)
+{
+
+}
+
+static void
+gst_base_video_parse_class_init (GstBaseVideoParseClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->finalize = gst_base_video_parse_finalize;
+
+  element_class->change_state = gst_base_video_parse_change_state;
+}
+
+static void
+gst_base_video_parse_init (GstBaseVideoParse * base_video_parse,
+    GstBaseVideoParseClass * klass)
+{
+  GstPad *pad;
+
+  GST_DEBUG ("gst_base_video_parse_init");
+
+  pad = GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_parse);
+
+  gst_pad_set_chain_function (pad, gst_base_video_parse_chain);
+  gst_pad_set_query_function (pad, gst_base_video_parse_sink_query);
+  gst_pad_set_event_function (pad, gst_base_video_parse_sink_event);
+
+  pad = GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse);
+
+  gst_pad_set_query_type_function (pad, gst_base_video_parse_get_query_types);
+  gst_pad_set_query_function (pad, gst_base_video_parse_src_query);
+  gst_pad_set_event_function (pad, gst_base_video_parse_src_event);
+
+  base_video_parse->input_adapter = gst_adapter_new ();
+  base_video_parse->output_adapter = gst_adapter_new ();
+
+  base_video_parse->reorder_depth = 1;
+
+  base_video_parse->current_frame =
+      gst_base_video_parse_new_frame (base_video_parse);
+}
+
+static void
+gst_base_video_parse_reset (GstBaseVideoParse * base_video_parse)
+{
+  GST_DEBUG ("reset");
+
+  base_video_parse->discont = TRUE;
+  base_video_parse->have_sync = FALSE;
+
+  base_video_parse->system_frame_number = 0;
+  base_video_parse->presentation_frame_number = 0;
+
+  if (base_video_parse->caps) {
+    gst_caps_unref (base_video_parse->caps);
+    base_video_parse->caps = NULL;
+  }
+
+  gst_segment_init (&base_video_parse->state.segment, GST_FORMAT_TIME);
+  gst_adapter_clear (base_video_parse->input_adapter);
+  gst_adapter_clear (base_video_parse->output_adapter);
+
+  if (base_video_parse->current_frame) {
+    gst_base_video_parse_free_frame (base_video_parse->current_frame);
+  }
+  base_video_parse->current_frame =
+      gst_base_video_parse_new_frame (base_video_parse);
+
+}
+
+static void
+gst_base_video_parse_finalize (GObject * object)
+{
+  GstBaseVideoParse *base_video_parse;
+
+  g_return_if_fail (GST_IS_BASE_VIDEO_PARSE (object));
+  base_video_parse = GST_BASE_VIDEO_PARSE (object);
+
+  if (base_video_parse->input_adapter) {
+    g_object_unref (base_video_parse->input_adapter);
+  }
+  if (base_video_parse->output_adapter) {
+    g_object_unref (base_video_parse->output_adapter);
+  }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static const GstQueryType *
+gst_base_video_parse_get_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_POSITION,
+    GST_QUERY_DURATION,
+    GST_QUERY_CONVERT,
+    0
+  };
+
+  return query_types;
+}
+
+#if 0
+static gboolean
+gst_base_video_parse_src_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res;
+  GstBaseVideoParse *dec;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
+    if (dec->fps_d != 0) {
+      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+          dec->fps_d * GST_SECOND, dec->fps_n);
+      res = TRUE;
+    } else {
+      res = FALSE;
+    }
+  } else {
+    GST_WARNING ("unhandled conversion from %d to %d", src_format,
+        *dest_format);
+    res = FALSE;
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+
+static gboolean
+gst_base_video_parse_sink_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstBaseVideoParse *dec;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a decoding state */
+
+  switch (src_format) {
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (src_value,
+              dec->fps_d * GST_SECOND, dec->fps_n);
+          break;
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_TIME:
+      switch (*dest_format) {
+        case GST_FORMAT_DEFAULT:
+        {
+          *dest_value = gst_util_uint64_scale (src_value,
+              dec->fps_n, dec->fps_d * GST_SECOND);
+          break;
+        }
+        default:
+          res = FALSE;
+          break;
+      }
+      break;
+    default:
+      res = FALSE;
+      break;
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+#endif
+
+static gboolean
+gst_base_video_parse_src_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoParse *base_parse;
+  gboolean res = FALSE;
+
+  base_parse = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_POSITION:
+    {
+      GstFormat format;
+      gint64 time;
+      gint64 value;
+
+      gst_query_parse_position (query, &format, NULL);
+
+      time = gst_util_uint64_scale (base_parse->presentation_frame_number,
+          base_parse->state.fps_n, base_parse->state.fps_d);
+      time += base_parse->state.segment.time;
+      GST_DEBUG ("query position %" G_GINT64_FORMAT, time);
+      res = gst_base_video_encoded_video_convert (&base_parse->state,
+          GST_FORMAT_TIME, time, &format, &value);
+      if (!res)
+        goto error;
+
+      gst_query_set_position (query, format, value);
+      break;
+    }
+    case GST_QUERY_DURATION:
+      res =
+          gst_pad_query (GST_PAD_PEER (GST_BASE_VIDEO_CODEC_SINK_PAD
+              (base_parse)), query);
+      if (!res)
+        goto error;
+      break;
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      GST_WARNING ("query convert");
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&base_parse->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_parse);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_parse, "query failed");
+  goto done;
+}
+
+static gboolean
+gst_base_video_parse_sink_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoParse *base_video_parse;
+  gboolean res = FALSE;
+
+  base_video_parse = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&base_video_parse->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_video_parse);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_video_parse, "query failed");
+  goto done;
+}
+
+static gboolean
+gst_base_video_parse_src_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoParse *base_video_parse;
+  gboolean res = FALSE;
+
+  base_video_parse = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:
+    {
+      GstFormat format, tformat;
+      gdouble rate;
+      GstEvent *real_seek;
+      GstSeekFlags flags;
+      GstSeekType cur_type, stop_type;
+      gint64 cur, stop;
+      gint64 tcur, tstop;
+
+      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type,
+          &cur, &stop_type, &stop);
+      gst_event_unref (event);
+
+      tformat = GST_FORMAT_TIME;
+      res = gst_base_video_encoded_video_convert (&base_video_parse->state,
+          format, cur, &tformat, &tcur);
+      if (!res)
+        goto convert_error;
+      res = gst_base_video_encoded_video_convert (&base_video_parse->state,
+          format, stop, &tformat, &tstop);
+      if (!res)
+        goto convert_error;
+
+      real_seek = gst_event_new_seek (rate, GST_FORMAT_TIME,
+          flags, cur_type, tcur, stop_type, tstop);
+
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_parse),
+          real_seek);
+
+      break;
+    }
+#if 0
+    case GST_EVENT_QOS:
+    {
+      gdouble proportion;
+      GstClockTimeDiff diff;
+      GstClockTime timestamp;
+
+      gst_event_parse_qos (event, &proportion, &diff, &timestamp);
+
+      GST_OBJECT_LOCK (base_video_parse);
+      base_video_parse->proportion = proportion;
+      base_video_parse->earliest_time = timestamp + diff;
+      GST_OBJECT_UNLOCK (base_video_parse);
+
+      GST_DEBUG_OBJECT (base_video_parse,
+          "got QoS %" GST_TIME_FORMAT ", %" G_GINT64_FORMAT,
+          GST_TIME_ARGS (timestamp), diff);
+
+      res = gst_pad_push_event (base_video_parse->sinkpad, event);
+      break;
+    }
+#endif
+    default:
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_parse),
+          event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_parse);
+  return res;
+
+convert_error:
+  GST_DEBUG_OBJECT (base_video_parse, "could not convert format");
+  goto done;
+}
+
+static gboolean
+gst_base_video_parse_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoParse *base_video_parse;
+  gboolean ret = FALSE;
+
+  base_video_parse = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_START:
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      gst_base_video_parse_reset (base_video_parse);
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+    case GST_EVENT_EOS:
+      if (gst_base_video_parse_push_all (base_video_parse,
+              FALSE) == GST_FLOW_ERROR) {
+        gst_event_unref (event);
+        return FALSE;
+      }
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      gboolean update;
+      GstFormat format;
+      gdouble rate;
+      gint64 start, stop, time;
+
+      gst_event_parse_new_segment (event, &update, &rate, &format, &start,
+          &stop, &time);
+
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      if (rate <= 0.0)
+        goto newseg_wrong_rate;
+
+      GST_DEBUG ("newsegment %" G_GINT64_FORMAT " %" G_GINT64_FORMAT, start,
+          time);
+      gst_segment_set_newsegment (&base_video_parse->state.segment, update,
+          rate, format, start, stop, time);
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+    }
+    default:
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_parse);
+  return ret;
+
+newseg_wrong_format:
+  GST_DEBUG_OBJECT (base_video_parse, "received non TIME newsegment");
+  gst_event_unref (event);
+  goto done;
+
+newseg_wrong_rate:
+  GST_DEBUG_OBJECT (base_video_parse, "negative rates not supported");
+  gst_event_unref (event);
+  goto done;
+}
+
+
+static GstStateChangeReturn
+gst_base_video_parse_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstBaseVideoParse *base_parse = GST_BASE_VIDEO_PARSE (element);
+  GstStateChangeReturn ret;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_base_video_parse_reset (base_parse);
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_base_video_parse_reset (base_parse);
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static guint64
+gst_base_video_parse_get_timestamp (GstBaseVideoParse * base_video_parse,
+    int picture_number)
+{
+  if (picture_number < 0) {
+    return base_video_parse->timestamp_offset -
+        (gint64) gst_util_uint64_scale (-picture_number,
+        base_video_parse->state.fps_d * GST_SECOND,
+        base_video_parse->state.fps_n);
+  } else {
+    return base_video_parse->timestamp_offset +
+        gst_util_uint64_scale (picture_number,
+        base_video_parse->state.fps_d * GST_SECOND,
+        base_video_parse->state.fps_n);
+  }
+}
+
+static GstFlowReturn
+gst_base_video_parse_push_all (GstBaseVideoParse * base_video_parse,
+    gboolean at_eos)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  /* FIXME do stuff */
+
+  return ret;
+}
+
+static GstBuffer *
+gst_adapter_get_buffer (GstAdapter * adapter)
+{
+  return gst_buffer_ref (GST_BUFFER (adapter->buflist->data));
+
+}
+
+static GstFlowReturn
+gst_base_video_parse_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstBaseVideoParse *base_video_parse;
+  GstBaseVideoParseClass *klass;
+  GstBuffer *buffer;
+  GstFlowReturn ret;
+
+  GST_DEBUG ("chain with %d bytes", GST_BUFFER_SIZE (buf));
+
+  base_video_parse = GST_BASE_VIDEO_PARSE (GST_PAD_PARENT (pad));
+  klass = GST_BASE_VIDEO_PARSE_GET_CLASS (base_video_parse);
+
+  if (!base_video_parse->started) {
+    klass->start (base_video_parse);
+    base_video_parse->started = TRUE;
+  }
+
+  if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))) {
+    GST_DEBUG_OBJECT (base_video_parse, "received DISCONT buffer");
+    gst_base_video_parse_reset (base_video_parse);
+    base_video_parse->discont = TRUE;
+    base_video_parse->have_sync = FALSE;
+  }
+
+  if (GST_BUFFER_TIMESTAMP (buf) != GST_CLOCK_TIME_NONE) {
+    base_video_parse->last_timestamp = GST_BUFFER_TIMESTAMP (buf);
+  }
+  gst_adapter_push (base_video_parse->input_adapter, buf);
+
+  if (!base_video_parse->have_sync) {
+    int n, m;
+
+    GST_DEBUG ("no sync, scanning");
+
+    n = gst_adapter_available (base_video_parse->input_adapter);
+    m = klass->scan_for_sync (base_video_parse->input_adapter, FALSE, 0, n);
+
+    gst_adapter_flush (base_video_parse->input_adapter, m);
+
+    if (m < n) {
+      GST_DEBUG ("found possible sync after %d bytes (of %d)", m, n);
+
+      /* this is only "maybe" sync */
+      base_video_parse->have_sync = TRUE;
+    }
+
+    if (!base_video_parse->have_sync) {
+      return GST_FLOW_OK;
+    }
+  }
+
+  /* FIXME: use gst_adapter_prev_timestamp() here instead? */
+  buffer = gst_adapter_get_buffer (base_video_parse->input_adapter);
+
+  gst_buffer_unref (buffer);
+
+  /* FIXME check klass->parse_data */
+
+  do {
+    ret = klass->parse_data (base_video_parse, FALSE);
+  } while (ret == GST_FLOW_OK);
+
+  if (ret == GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA) {
+    return GST_FLOW_OK;
+  }
+  return ret;
+}
+
+GstVideoState *
+gst_base_video_parse_get_state (GstBaseVideoParse * base_video_parse)
+{
+  return &base_video_parse->state;
+}
+
+void
+gst_base_video_parse_set_state (GstBaseVideoParse * base_video_parse,
+    GstVideoState * state)
+{
+  GST_DEBUG ("set_state");
+
+  memcpy (&base_video_parse->state, state, sizeof (GstVideoState));
+
+  /* FIXME set caps */
+
+}
+
+
+gboolean
+gst_base_video_parse_set_src_caps (GstBaseVideoParse * base_video_parse,
+    GstCaps * caps)
+{
+  g_return_val_if_fail (GST_IS_BASE_VIDEO_PARSE (base_video_parse), FALSE);
+
+  GST_DEBUG ("set_src_caps");
+
+  return gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+      caps);
+}
+
+void
+gst_base_video_parse_lost_sync (GstBaseVideoParse * base_video_parse)
+{
+  g_return_if_fail (GST_IS_BASE_VIDEO_PARSE (base_video_parse));
+
+  GST_DEBUG ("lost_sync");
+
+  if (gst_adapter_available (base_video_parse->input_adapter) >= 1) {
+    gst_adapter_flush (base_video_parse->input_adapter, 1);
+  }
+
+  base_video_parse->have_sync = FALSE;
+}
+
+GstVideoFrame *
+gst_base_video_parse_get_frame (GstBaseVideoParse * base_video_parse)
+{
+  g_return_val_if_fail (GST_IS_BASE_VIDEO_PARSE (base_video_parse), NULL);
+
+  return base_video_parse->current_frame;
+}
+
+void
+gst_base_video_parse_add_to_frame (GstBaseVideoParse * base_video_parse,
+    int n_bytes)
+{
+  GstBuffer *buf;
+
+  GST_DEBUG ("add_to_frame");
+
+  buf = gst_adapter_take_buffer (base_video_parse->input_adapter, n_bytes);
+
+  gst_adapter_push (base_video_parse->output_adapter, buf);
+}
+
+GstFlowReturn
+gst_base_video_parse_finish_frame (GstBaseVideoParse * base_video_parse)
+{
+  GstVideoFrame *frame = base_video_parse->current_frame;
+  GstBuffer *buffer;
+  GstBaseVideoParseClass *base_video_parse_class;
+  GstFlowReturn ret;
+
+  GST_DEBUG ("finish_frame");
+
+  base_video_parse_class = GST_BASE_VIDEO_PARSE_GET_CLASS (base_video_parse);
+
+  buffer = gst_adapter_take_buffer (base_video_parse->output_adapter,
+      gst_adapter_available (base_video_parse->output_adapter));
+
+  if (frame->is_sync_point) {
+    base_video_parse->timestamp_offset = base_video_parse->last_timestamp -
+        gst_util_uint64_scale (frame->presentation_frame_number,
+        base_video_parse->state.fps_d * GST_SECOND,
+        base_video_parse->state.fps_n);
+    base_video_parse->distance_from_sync = 0;
+  }
+
+  frame->distance_from_sync = base_video_parse->distance_from_sync;
+  base_video_parse->distance_from_sync++;
+
+  frame->presentation_timestamp =
+      gst_base_video_parse_get_timestamp (base_video_parse,
+      frame->presentation_frame_number);
+  frame->presentation_duration =
+      gst_base_video_parse_get_timestamp (base_video_parse,
+      frame->presentation_frame_number + 1) - frame->presentation_timestamp;
+  frame->decode_timestamp =
+      gst_base_video_parse_get_timestamp (base_video_parse,
+      frame->decode_frame_number);
+
+  GST_BUFFER_TIMESTAMP (buffer) = frame->presentation_timestamp;
+  GST_BUFFER_DURATION (buffer) = frame->presentation_duration;
+  if (frame->decode_frame_number < 0) {
+    GST_BUFFER_OFFSET (buffer) = 0;
+  } else {
+    GST_BUFFER_OFFSET (buffer) = frame->decode_timestamp;
+  }
+  GST_BUFFER_OFFSET_END (buffer) = GST_CLOCK_TIME_NONE;
+
+  GST_DEBUG ("pts %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (frame->presentation_timestamp));
+  GST_DEBUG ("dts %" GST_TIME_FORMAT, GST_TIME_ARGS (frame->decode_timestamp));
+  GST_DEBUG ("dist %d", frame->distance_from_sync);
+
+  if (frame->is_sync_point) {
+    GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  frame->src_buffer = buffer;
+  ret = base_video_parse_class->shape_output (base_video_parse, frame);
+
+  gst_base_video_parse_free_frame (base_video_parse->current_frame);
+
+  /* create new frame */
+  base_video_parse->current_frame =
+      gst_base_video_parse_new_frame (base_video_parse);
+
+  return ret;
+}
+
+static void
+gst_base_video_parse_free_frame (GstVideoFrame * frame)
+{
+  if (frame->sink_buffer) {
+    gst_buffer_unref (frame->sink_buffer);
+  }
+#if 0
+  if (frame->src_buffer) {
+    gst_buffer_unref (frame->src_buffer);
+  }
+#endif
+
+  g_free (frame);
+}
+
+static GstVideoFrame *
+gst_base_video_parse_new_frame (GstBaseVideoParse * base_video_parse)
+{
+  GstVideoFrame *frame;
+
+  frame = g_malloc0 (sizeof (GstVideoFrame));
+
+  frame->system_frame_number = base_video_parse->system_frame_number;
+  base_video_parse->system_frame_number++;
+
+  frame->decode_frame_number = frame->system_frame_number -
+      base_video_parse->reorder_depth;
+
+  return frame;
+}
+
+void
+gst_base_video_parse_set_sync_point (GstBaseVideoParse * base_video_parse)
+{
+  GST_DEBUG ("set_sync_point");
+
+  base_video_parse->current_frame->is_sync_point = TRUE;
+
+  base_video_parse->distance_from_sync = 0;
+}
+
+GstFlowReturn
+gst_base_video_parse_push (GstBaseVideoParse * base_video_parse,
+    GstBuffer * buffer)
+{
+  GstBaseVideoParseClass *base_video_parse_class;
+
+  base_video_parse_class = GST_BASE_VIDEO_PARSE_GET_CLASS (base_video_parse);
+
+  if (base_video_parse->caps == NULL) {
+    gboolean ret;
+
+    base_video_parse->caps =
+        base_video_parse_class->get_caps (base_video_parse);
+
+    ret = gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+        base_video_parse->caps);
+
+    if (!ret) {
+      GST_WARNING ("pad didn't accept caps");
+      return GST_FLOW_ERROR;
+    }
+  }
+  gst_buffer_set_caps (buffer, base_video_parse->caps);
+
+  GST_DEBUG ("pushing ts=%" G_GINT64_FORMAT " dur=%" G_GINT64_FORMAT " off=%"
+      G_GINT64_FORMAT " off_end=%" G_GINT64_FORMAT,
+      GST_BUFFER_TIMESTAMP (buffer), GST_BUFFER_DURATION (buffer),
+      GST_BUFFER_OFFSET (buffer), GST_BUFFER_OFFSET_END (buffer));
+
+  if (base_video_parse->discont) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+    base_video_parse->discont = FALSE;
+  } else {
+    GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DISCONT);
+  }
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse), buffer);
+}
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoparse.h schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoparse.h
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoparse.h	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoparse.h	2009-09-11 17:35:39.000000000 +0200
@@ -0,0 +1,141 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_PARSE_H_
+#define _GST_BASE_VIDEO_PARSE_H_
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "GstBaseVideoParse is unstable API and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/video/gstbasevideocodec.h>
+#include <gst/video/gstbasevideoutils.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_BASE_VIDEO_PARSE \
+  (gst_base_video_parse_get_type())
+#define GST_BASE_VIDEO_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_VIDEO_PARSE,GstBaseVideoParse))
+#define GST_BASE_VIDEO_PARSE_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_VIDEO_PARSE,GstBaseVideoParseClass))
+#define GST_BASE_VIDEO_PARSE_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_BASE_VIDEO_PARSE,GstBaseVideoParseClass))
+#define GST_IS_BASE_VIDEO_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_VIDEO_PARSE))
+#define GST_IS_BASE_VIDEO_PARSE_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_VIDEO_PARSE))
+
+/**
+ * GST_BASE_VIDEO_PARSE_SINK_NAME:
+ *
+ * The name of the templates for the sink pad.
+ */
+#define GST_BASE_VIDEO_PARSE_SINK_NAME    "sink"
+/**
+ * GST_BASE_VIDEO_PARSE_SRC_NAME:
+ *
+ * The name of the templates for the source pad.
+ */
+#define GST_BASE_VIDEO_PARSE_SRC_NAME     "src"
+
+/**
+ * GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA:
+ *
+ */
+#define GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
+
+typedef struct _GstBaseVideoParse GstBaseVideoParse;
+typedef struct _GstBaseVideoParseClass GstBaseVideoParseClass;
+
+struct _GstBaseVideoParse
+{
+  GstBaseVideoCodec base_video_codec;
+
+  /*< private >*/
+  GstAdapter *input_adapter;
+  GstAdapter *output_adapter;
+
+  int reorder_depth;
+
+  gboolean have_sync;
+  gboolean discont;
+  gboolean started;
+
+  GstVideoFrame *current_frame;
+  GstVideoState state;
+  int distance_from_sync;
+
+  gboolean sink_clipping;
+
+  guint64 presentation_frame_number;
+  guint64 system_frame_number;
+
+  GstCaps *caps;
+  gboolean set_output_caps;
+
+  GstClockTime last_timestamp;
+
+  gint64 timestamp_offset;
+};
+
+struct _GstBaseVideoParseClass
+{
+  GstBaseVideoCodecClass base_video_codec_class;
+
+  gboolean (*start) (GstBaseVideoParse *parse);
+  gboolean (*stop) (GstBaseVideoParse *parse);
+  gboolean (*reset) (GstBaseVideoParse *parse);
+  GstFlowReturn (*parse_data) (GstBaseVideoParse *parse, gboolean at_eos);
+  int (*scan_for_sync) (GstAdapter *adapter, gboolean at_eos,
+      int offset, int n);
+  GstFlowReturn (*shape_output) (GstBaseVideoParse *parse, GstVideoFrame *frame);
+  GstCaps *(*get_caps) (GstBaseVideoParse *parse);
+
+};
+
+GType gst_base_video_parse_get_type (void);
+
+int gst_base_video_parse_get_width (GstBaseVideoParse *parse);
+int gst_base_video_parse_get_height (GstBaseVideoParse *parse);
+GstVideoState *gst_base_video_parse_get_state (GstBaseVideoParse *parse);
+void gst_base_video_parse_set_state (GstBaseVideoParse *parse,
+    GstVideoState *state);
+
+guint64 gst_base_video_parse_get_timestamp_offset (GstBaseVideoParse *parse);
+
+gboolean gst_base_video_parse_set_src_caps (GstBaseVideoParse *base_video_parse, GstCaps *caps);
+
+GstFlowReturn gst_base_video_parse_end_of_stream (GstBaseVideoParse *base_video_parse,
+    GstBuffer *buffer);
+
+void gst_base_video_parse_lost_sync (GstBaseVideoParse *base_video_parse);
+
+GstVideoFrame * gst_base_video_parse_get_frame (GstBaseVideoParse *base_video_parse);
+void gst_base_video_parse_add_to_frame (GstBaseVideoParse *base_video_parse, int n_bytes);
+GstFlowReturn gst_base_video_parse_finish_frame (GstBaseVideoParse *base_video_parse);
+void gst_base_video_parse_set_sync_point (GstBaseVideoParse *base_video_parse);
+GstFlowReturn gst_base_video_parse_push (GstBaseVideoParse *base_video_parse,
+    GstBuffer *buffer);
+
+G_END_DECLS
+
+#endif
+
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoutils.c schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoutils.c
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoutils.c	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoutils.c	2009-10-12 12:23:39.000000000 +0200
@@ -0,0 +1,163 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideoutils.h"
+
+#include <string.h>
+
+GST_DEBUG_CATEGORY_EXTERN (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+
+guint64
+gst_base_video_convert_bytes_to_frames (GstVideoState * state, guint64 bytes)
+{
+  return gst_util_uint64_scale_int (bytes, 1, state->bytes_per_picture);
+}
+
+guint64
+gst_base_video_convert_frames_to_bytes (GstVideoState * state, guint64 frames)
+{
+  return frames * state->bytes_per_picture;
+}
+
+
+gboolean
+gst_base_video_rawvideo_convert (GstVideoState * state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = FALSE;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  if (src_format == GST_FORMAT_BYTES &&
+      *dest_format == GST_FORMAT_DEFAULT && state->bytes_per_picture != 0) {
+    /* convert bytes to frames */
+    *dest_value = gst_util_uint64_scale_int (src_value, 1,
+        state->bytes_per_picture);
+    res = TRUE;
+  } else if (src_format == GST_FORMAT_DEFAULT &&
+      *dest_format == GST_FORMAT_BYTES && state->bytes_per_picture != 0) {
+    /* convert bytes to frames */
+    *dest_value = src_value * state->bytes_per_picture;
+    res = TRUE;
+  } else if (src_format == GST_FORMAT_DEFAULT &&
+      *dest_format == GST_FORMAT_TIME && state->fps_n != 0) {
+    /* convert frames to time */
+    /* FIXME add segment time? */
+    *dest_value = gst_util_uint64_scale (src_value,
+        GST_SECOND * state->fps_d, state->fps_n);
+    res = TRUE;
+  } else if (src_format == GST_FORMAT_TIME &&
+      *dest_format == GST_FORMAT_DEFAULT && state->fps_d != 0) {
+    /* convert time to frames */
+    /* FIXME subtract segment time? */
+    *dest_value = gst_util_uint64_scale (src_value, state->fps_n,
+        GST_SECOND * state->fps_d);
+    res = TRUE;
+  }
+
+  /* FIXME add bytes <--> time */
+
+  return res;
+}
+
+gboolean
+gst_base_video_encoded_video_convert (GstVideoState * state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = FALSE;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  GST_DEBUG ("src convert");
+
+#if 0
+  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
+    if (dec->fps_d != 0) {
+      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+          dec->fps_d * GST_SECOND, dec->fps_n);
+      res = TRUE;
+    } else {
+      res = FALSE;
+    }
+  } else {
+    GST_WARNING ("unhandled conversion from %d to %d", src_format,
+        *dest_format);
+    res = FALSE;
+  }
+#endif
+
+  return res;
+}
+
+gboolean
+gst_base_video_state_from_caps (GstVideoState * state, GstCaps * caps)
+{
+
+  gst_video_format_parse_caps (caps, &state->format,
+      &state->width, &state->height);
+
+  if (!gst_video_parse_caps_framerate (caps, &state->fps_n, &state->fps_d))
+    return FALSE;
+
+  state->par_n = 1;
+  state->par_d = 1;
+  gst_video_parse_caps_pixel_aspect_ratio (caps, &state->par_n, &state->par_d);
+
+  {
+    GstStructure *structure = gst_caps_get_structure (caps, 0);
+    state->interlaced = FALSE;
+    gst_structure_get_boolean (structure, "interlaced", &state->interlaced);
+  }
+
+  state->clean_width = state->width;
+  state->clean_height = state->height;
+  state->clean_offset_left = 0;
+  state->clean_offset_top = 0;
+
+  /* FIXME need better error handling */
+  return TRUE;
+}
+
+GstClockTime
+gst_video_state_get_timestamp (const GstVideoState * state, int frame_number)
+{
+  if (frame_number < 0) {
+    return state->segment.start -
+        (gint64) gst_util_uint64_scale (-frame_number,
+        state->fps_d * GST_SECOND, state->fps_n);
+  } else {
+    return state->segment.start +
+        gst_util_uint64_scale (frame_number,
+        state->fps_d * GST_SECOND, state->fps_n);
+  }
+}
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoutils.h schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoutils.h
--- schroedinger-1.0.8.orig/gst-libs/gst/video/gstbasevideoutils.h	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/gstbasevideoutils.h	2009-09-11 17:35:39.000000000 +0200
@@ -0,0 +1,95 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_UTILS_H_
+#define _GST_BASE_VIDEO_UTILS_H_
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "The base video utils API is unstable and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/base/gstadapter.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstVideoState GstVideoState;
+typedef struct _GstVideoFrame GstVideoFrame;
+
+struct _GstVideoState
+{
+  GstVideoFormat format;
+  int width, height;
+  int fps_n, fps_d;
+  int par_n, par_d;
+  gboolean interlaced;
+  gboolean top_field_first;
+
+  int clean_width, clean_height;
+  int clean_offset_left, clean_offset_top;
+
+  int bytes_per_picture;
+
+  GstSegment segment;
+
+  int picture_number;
+};
+
+struct _GstVideoFrame
+{
+  guint64 decode_timestamp;
+  guint64 presentation_timestamp;
+  guint64 presentation_duration;
+
+  gint system_frame_number;
+  gint decode_frame_number;
+  gint presentation_frame_number;
+
+  int distance_from_sync;
+  gboolean is_sync_point;
+  gboolean is_eos;
+
+  GstBuffer *sink_buffer;
+  GstBuffer *src_buffer;
+
+  int field_index;
+  int n_fields;
+
+  void *coder_hook;
+};
+
+gboolean gst_base_video_rawvideo_convert (GstVideoState *state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 *dest_value);
+gboolean gst_base_video_encoded_video_convert (GstVideoState *state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 *dest_value);
+
+gboolean gst_base_video_state_from_caps (GstVideoState *state,
+    GstCaps *caps);
+
+GstClockTime gst_video_state_get_timestamp (const GstVideoState *state,
+    int frame_number);
+
+G_END_DECLS
+
+#endif
+
diff -uNr schroedinger-1.0.8.orig/gst-libs/gst/video/Makefile.am schroedinger-1.0.8/gst-libs/gst/video/Makefile.am
--- schroedinger-1.0.8.orig/gst-libs/gst/video/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ schroedinger-1.0.8/gst-libs/gst/video/Makefile.am	2009-09-11 17:35:39.000000000 +0200
@@ -0,0 +1,24 @@
+
+lib_LTLIBRARIES = libgstbasevideo-@GST_MAJORMINOR@.la
+
+CLEANFILES = $(BUILT_SOURCES)
+
+libgstbasevideo_@GST_MAJORMINOR@_la_SOURCES = \
+	gstbasevideoutils.c \
+	gstbasevideocodec.c \
+	gstbasevideodecoder.c \
+	gstbasevideoencoder.c \
+	gstbasevideoparse.c
+
+libgstbasevideo_@GST_MAJORMINOR@includedir = $(includedir)/gstreamer-@GST_MAJORMINOR@/gst/video
+libgstbasevideo_@GST_MAJORMINOR@include_HEADERS = \
+	gstbasevideoutils.h \
+	gstbasevideocodec.h \
+	gstbasevideodecoder.h \
+	gstbasevideoencoder.h \
+	gstbasevideoparse.h
+
+libgstbasevideo_@GST_MAJORMINOR@_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) -DGST_USE_UNSTABLE_API -I$(top_srcdir)/gst-libs
+libgstbasevideo_@GST_MAJORMINOR@_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) $(GST_BASE_LIBS) $(GST_LIBS) -lgstvideo-@GST_MAJORMINOR@
+libgstbasevideo_@GST_MAJORMINOR@_la_LDFLAGS = $(GST_LIB_LDFLAGS) $(GST_ALL_LDFLAGS) $(GST_LT_LDFLAGS) -static
+
